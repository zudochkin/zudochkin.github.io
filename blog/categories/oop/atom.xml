<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: OOP | Записки Вредного программиста]]></title>
  <link href="http://zudochkin.ru/blog/categories/oop/atom.xml" rel="self"/>
  <link href="http://zudochkin.ru/"/>
  <updated>2014-02-23T20:16:54+04:00</updated>
  <id>http://zudochkin.ru/</id>
  <author>
    <name><![CDATA[Зудочкин Дима]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Покерный класс на PHP]]></title>
    <link href="http://zudochkin.ru/2011/08/poker-class-php"/>
    <updated>2011-08-11T13:52:41+04:00</updated>
    <id>http://zudochkin.ru/2011/08/poker-class-php</id>
    <content type="html"><![CDATA[<p>Приветствую тебя, разработчик или случайно зашедший на огонек в этот уютный технический бложек. Сегодня речь пойдет о несколько математической задаче, хоть и немного там математики, да и она понятна школьнику 5го класса. Сегодня мы научимся распознавать комбинации в Техасском холдеме, именно в такую разновидность покера я играю (играл). Т.к. это очень простой класс на PHP, он не будет иметь определять старшинство одинаковых по названию комбинаций, но разнящихся по номиналу, к примеру стрит до 10 и стрит до 8 будут трактоваться этим классом, как просто стрит. В Техасском холдеме всего 10 комбинаций и мы с вами пройдемся от самой старшей из них &ndash; флеш рояль до самой младшей &ndash; старшая карта.</p>

<!-- more -->


<h6>Флеш рояль</h6>

<p>Высшая кобинация в покере &ndash; это стрит (стрейт) флеш до туза.</p>

<p>``` php
protected function _isRoyalFlush()
{</p>

<pre><code>return ($this-&gt;_isFlush() &amp;&amp; $this-&gt;_isStraight() &amp;&amp; array_search(14, $this-&gt;_ranks) &amp;&amp; array_search('13', $this-&gt;_ranks));
</code></pre>

<p>}
```</p>

<p><img class="image" src="/images/posts/2011-08-poker-class-php/poker-class-php-300x214.jpg"></p>

<p>Немного костыльный способ проверки на флеш рояль: проверяем на наличие стрита, флеша и чтобы наличствовали туз и кароль.</p>

<h6>Каре или Quad</h6>

<p>Тут проще некуда, нужно наличие четырех одинаковых карт.</p>

<p>``` php
protected function _isQuad()
{</p>

<pre><code>$test = $this-&gt;_ranks;

$uniqueElementsCount = array();

foreach($this-&gt;_ranks as $key =&gt; $card) {
    $test = $this-&gt;_ranks;
    unset($test[$key]);
    $uniqueElementsCount[] = count(array_unique($test));
}


return 1 === min($uniqueElementsCount);
</code></pre>

<p>}
```</p>

<h6>Стрит флеш</h6>

<p>Тот же самый флешрояль, только необязательно, чтобы стрит был до туза (10-валет-дама-кароль-туз).</p>

<p>``` php
protected function _isStraightFlush()
{</p>

<pre><code>return ($this-&gt;_isFlush() &amp;&amp; $this-&gt;_isStraight());
</code></pre>

<p>}
```</p>

<h6>Фул хаус</h6>

<p>Это когда три карты одного достоинства и две другого. Не самая удачная реализация :)</p>

<p>``` php
protected function _isFullHouse()
{</p>

<pre><code>$ranks = $this-&gt;_ranks;
sort($ranks);

if ((($ranks[0] == $ranks[1] &amp;&amp; $ranks[1] == $ranks[2]) &amp;&amp; ($ranks[3] == $ranks[4])) // 1=2=3 and 4=5
        || ($ranks[0] == $ranks[1]) &amp;&amp; ($ranks[2] == $ranks[3] and $ranks[3] == $ranks[4])) // 1=2 and 3=4=5
    return true;

return false;
}
</code></pre>

<p>```</p>

<h6>Флеш</h6>

<p>Все карты в комбинации должны быть одной масти. Проверяет все очень просто: сортируется массив с мастями и проверяется на равенство первая и последняя карты.</p>

<p>``` php
protected function _isFlush()
{</p>

<pre><code>$suits = $this-&gt;_suits;
sort($suits);
if ($suits[0] === $suits[4])
    return true;

return false;
</code></pre>

<p>}
```</p>

<h6>Стрит</h6>

<p>Вне зависимости от масти, достоинство карт должно быть по старшенству (5 подряд). Из-за того, что туз может в зависимости от ситуации быть и самой старшей, и самой младшей картой, пришлось сделать две проверки.</p>

<p>``` php
protected function _isStraight()
{</p>

<pre><code>$ranks = $this-&gt;_ranks;
sort($ranks);

// if Ace is low card in straight
if ($key = array_search(14, $ranks)) {
    $tempRanks = $ranks;
    unset($tempRanks[$key]);
    if (array(2, 3, 4, 5) == $tempRanks) {
        return true;
    }
    unset($tempRanks);
}

// if Ace is high card - default algorithm
$min = $ranks[0];
foreach($ranks as $key =&gt; $value) {
    $ranks[$key] -= $min;
    if ($key != $ranks[$key])
        return false;
}
return true;
</code></pre>

<p>}
```</p>

<h6>Сет, трипс или тройка</h6>

<p>Нужно наличие трех одинаковых карт. Алгоритм опять же далек от совершенства, но он выполняет свою работу.</p>

<p>``` php
protected function _isThreeOfKind()
{</p>

<pre><code>$ranks = $this-&gt;_ranks;
sort($ranks);

if (($ranks[0] == $ranks[1] and $ranks[1] == $ranks[2])
        || ($ranks[1] == $ranks[2] and $ranks[2] == $ranks[3])
        || ($ranks[2] == $ranks[3] and $ranks[3] == $ranks[4]))
    return true;
return false;
</code></pre>

<p>}
```</p>

<h6>Две пары</h6>

<p>Из название алгоритма должно быть понятно что к чему.</p>

<p>``` php
protected function _isTwoPairs()
{</p>

<pre><code>$ranks = $this-&gt;_ranks;

foreach($ranks as $key =&gt; $rank) {
    $testRanks = $ranks;
    unset($testRanks[$key]);
    sort($testRanks);
    if (($testRanks[0] == $testRanks[1])
            and ($testRanks[2] == $testRanks[3])
            and ($testRanks[0] != $testRanks[2])
            // exclude full house
            and ($testRanks[0] != $ranks[$key])
            and ($testRanks[2] != $ranks[$key])
    )
        return true;
}
return false;
</code></pre>

<p>}
```</p>

<h6>Пара</h6>

<p>Количество уникальных карт из пяти должно равняться четырем, если опять же я ничего не перепутал :).</p>

<p>``` php
protected function _isPair()
{</p>

<pre><code>return 4 === count(array_unique($this-&gt;_ranks));
</code></pre>

<p>}
```</p>

<h6>Старшая карта</h6>

<p>Последний абзаци больше для красоты, потому что если ни одна комбинация не подошла, значит комбинация &ndash; старшая карта.</p>

<p>``` php
protected function _isHighCard()
{</p>

<pre><code>return true;
</code></pre>

<p>}
```</p>

<h6>Исходный код класса для опеределения покерных комбинаций на PHP</h6>

<p>``` php
&lt;?php
/<strong>
 * @author vredniy.ru
 *
</strong>/
class Poker
{</p>

<pre><code>protected $_cards = array();
//
protected $_ranks = array();
protected $_suits = array();

public function __construct(array $cards)
{
    $this-&gt;_cards = $cards;

    $rank = null;

    foreach($cards as $card) {
        switch (strtolower($card['rank'])) {
            case 't':
                $rank = 10;
                break;
            case 'j':
                $rank = '11';
                break;
            case 'q':
                $rank = '12';
                break;
            case 'k':
                $rank = '13';
                break;
            case 'a':
                $rank = '14';
                break;
                ;
            default:
                $rank = $card['rank'];
                break;
        }
        $this-&gt;_ranks[] = $rank;
        $this-&gt;_suits[] = $card['suit'];
    }
}

public function checkCombination()
{
    // is Royal Flush
    echo $this-&gt;_isRoyalFlush() ? 'royal flush' : 'not royal flush';
    echo '&lt;br&gt;';

    // is Quad (four of kind)
    echo $this-&gt;_isQuad() ? 'quad' : 'not quad';
    echo '&lt;br&gt;';

    // is StraightFlush
    echo $this-&gt;_isStraightFlush() ? 'straight flush' : 'not straight flush';
    echo '&lt;br&gt;';

    // is Full House
    echo $this-&gt;_isFullHouse() ? 'full house' : 'not full house';
    echo '&lt;br&gt;';

    // is Flush
    echo $this-&gt;_isFlush() ? 'flush' : 'not flush';
    echo '&lt;br&gt;';

    // is Straight
    echo $this-&gt;_isStraight() ? 'straight' : 'not straigt';
    echo '&lt;br&gt;';

    // is Three of Kind
    echo $this-&gt;_isThreeOfKind() ? 'three of kind' : 'not three of kind';
    echo '&lt;br&gt;';

    // is Two Pairs
    echo $this-&gt;_isTwoPairs() ? 'two pairs' : 'not two pairs';
    echo '&lt;br&gt;';

    // is one Pair
    echo $this-&gt;_isPair() ? 'pair' : 'not pair';
    echo '&lt;br&gt;';

    // is High Card
    echo $this-&gt;_isHighCard() ? 'high card' : 'not high card';
    echo '&lt;br&gt;';
}

/**
 * chech that combination is flush and straight and contains ace and king (exclude straight flush "ace-5")
 *
 * @return bool
 */
protected function _isRoyalFlush()
{
    return ($this-&gt;_isFlush() &amp;&amp; $this-&gt;_isStraight() &amp;&amp; array_search(14, $this-&gt;_ranks) &amp;&amp; array_search('13', $this-&gt;_ranks));
}

/**
 * check combination is quad (four of kind)
 *
 * @return bool
 */
protected function _isQuad()
{

    $test = $this-&gt;_ranks;

    $uniqueElementsCount = array();

    foreach($this-&gt;_ranks as $key =&gt; $card) {
        $test = $this-&gt;_ranks;
        unset($test[$key]);
        $uniqueElementsCount[] = count(array_unique($test));
    }


    return 1 === min($uniqueElementsCount);
}

/**
 * is a straight and a flush?
 *
 * @return bool
 */
protected function _isStraightFlush()
{
    return ($this-&gt;_isFlush() &amp;&amp; $this-&gt;_isStraight());
}

/**
 * is full house?
 * (1=2=3 and 4=5) or (1=2 and 3=4=5)
 *
 * @return bool
 */
protected function _isFullHouse()
{
    $ranks = $this-&gt;_ranks;
    sort($ranks);

    if ((($ranks[0] == $ranks[1] &amp;&amp; $ranks[1] == $ranks[2]) &amp;&amp; ($ranks[3] == $ranks[4])) // 1=2=3 and 4=5
            || ($ranks[0] == $ranks[1]) &amp;&amp; ($ranks[2] == $ranks[3] and $ranks[3] == $ranks[4])) // 1=2 and 3=4=5
        return true;

    return false;
}

/**
 * is flush?
 *
 * @return bool
 */
protected function _isFlush()
{
    $suits = $this-&gt;_suits;
    sort($suits);
    if ($suits[0] === $suits[4])
        return true;

    return false;
}

/**
 * check straight. 2 attempt, 'cause ace may be high card, or low.
 *
 * @return bool
 */
protected function _isStraight()
{

    $ranks = $this-&gt;_ranks;
    sort($ranks);

    // if Ace is low card in straight
    if ($key = array_search(14, $ranks)) {
        $tempRanks = $ranks;
        unset($tempRanks[$key]);
        if (array(2, 3, 4, 5) == $tempRanks) {
            return true;
        }
        unset($tempRanks);
    }

    // if Ace is high card - default algorithm
    $min = $ranks[0];
    foreach($ranks as $key =&gt; $value) {
        $ranks[$key] -= $min;
        if ($key != $ranks[$key])
            return false;
    }
    return true;
}

/**
 * is Three of kind
 *
 * @return bool
 */
protected function _isThreeOfKind()
{
    $ranks = $this-&gt;_ranks;
    sort($ranks);

    if (($ranks[0] == $ranks[1] and $ranks[1] == $ranks[2])
            || ($ranks[1] == $ranks[2] and $ranks[2] == $ranks[3])
            || ($ranks[2] == $ranks[3] and $ranks[3] == $ranks[4]))
        return true;
    return false;
}

/**
 * is two pairs
 *
 * @return bool
 */
protected function _isTwoPairs()
{
    $ranks = $this-&gt;_ranks;

    foreach($ranks as $key =&gt; $rank) {
        $testRanks = $ranks;
        unset($testRanks[$key]);
        sort($testRanks);
        if (($testRanks[0] == $testRanks[1])
                and ($testRanks[2] == $testRanks[3])
                and ($testRanks[0] != $testRanks[2])
                // exclude full house
                and ($testRanks[0] != $ranks[$key])
                and ($testRanks[2] != $ranks[$key])
        )
            return true;
    }
    return false;
}

/**
 * is single Pair
 *
 * @return bool
 */
protected function _isPair()
{
    return 4 === count(array_unique($this-&gt;_ranks));
}

/**
 * is High Card
 *
 * @return bool true
 */
protected function _isHighCard()
{
    return true;
}
</code></pre>

<p>}
```</p>

<h6>Небольшой пример использования</h6>

<p>``` php
&lt;?php</p>

<p>require_once &lsquo;Poker.php&rsquo;;</p>

<p>$cards = array(</p>

<pre><code>array('suit' =&gt; 's', 'rank' =&gt; '3'),
array('suit' =&gt; 's', 'rank' =&gt; '7'),
array('suit' =&gt; 's', 'rank' =&gt; 'a'),
array('suit' =&gt; 's', 'rank' =&gt; 't'),
array('suit' =&gt; 's', 'rank' =&gt; 't')
</code></pre>

<p>);</p>

<p>$poker = new Poker($cards);</p>

<p>$poker->checkCombination();
```</p>

<p>Комбинация из 5 карт для данного класса задается массивом из 5 элементов, которые в свою очередь явлеются ассоциативными массивами (suit &ndash; это масть, rank &ndash; достоинство карты).</p>

<h3>Эпилог</h3>

<p>Данный класс можно немного доработать, чтобы вместо название комбинаций, он выводил какой-нибудь балл комбинации, чтобы имелась возможность сравнивать две одинаковых комбинации, но это по желанию и выходит за пределы данной заметки. Также вы можете допилить проверку на корректность заданной комбинации. На этом на сегодня все.  Удачи вам в любых начинаниях и продолжениях.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Пишем свой первый фреймворк на PHP]]></title>
    <link href="http://zudochkin.ru/2011/06/mvc-framework-php"/>
    <updated>2011-06-11T20:15:56+04:00</updated>
    <id>http://zudochkin.ru/2011/06/mvc-framework-php</id>
    <content type="html"><![CDATA[<p>Привет тебе, коллега-разработчик или просто случайно зашедший на мой блог посетитель. В сегодняшней заметке я хочу рассказать вам о том, как прошел у меня вчерашний вечер (нет, нет, тут не будет ничего личного, аля покатался на роликах, попил пивка в парке). Как и у каждого веб-программиста рано или поздно возникает идея создать свой велосипед, пусть и с квадратными колесами и вместо руля торчащий штырь. Вчерашним велосипедом для меня стал легкий простой фреймворк, хотя с натяжкой его можно так назвать, но есть несколько моментов в нем, которые могут послужить отправной точкой для создание нечто большего. Ну обо всем по порядку.</p>

<!-- more -->


<h3>Структура папок</h3>

<p>Так как на меня большое влияние в последнее время оказал Zend Framework, структура папок, а также несколько еще штук будут очень похожи.</p>

<p>В корне мы имеем две папки <strong>app</strong> и <strong>library</strong>. Также в корне есть два файла (опять же все как у ZF) .htaccess (будет перенаправлять все запросы в index.php) и сам index.php, который эти самые запросы принимать будет.</p>

<h3>.htaccess и index.php</h3>

<p><img class="image" src="/images/posts/2011-06-mvc-framework-php/vredniy-simple-mvc-150x150.png"></p>

<p><strong>.htaccess</strong> полностью взял с ZF</p>

<p><code>
RewriteEngine On
RewriteCond %{REQUEST_FILENAME} -s [OR]
RewriteCond %{REQUEST_FILENAME} -l [OR]
RewriteCond %{REQUEST_FILENAME} -d
RewriteRule ^.*$ - [NC,L]
RewriteRule ^.*$ index.php [NC,L]
</code></p>

<p>Мне этого было более, чем достаточно. По сути этот .htaccess перенаправляет все запросы, если они не ведут на существующую директорию или файл нашему index.php.</p>

<p><strong>index.php</strong></p>

<p>``` php
&lt;?php
// объявляем нужные константы
define(&lsquo;APPLICATION_PATH&rsquo;, realpath(dirname(<strong>FILE</strong>) . DIRECTORY_SEPARATOR . &lsquo;app&rsquo;));
define(&lsquo;LIBRARY_PATH&rsquo;, realpath(dirname(<strong>FILE</strong>) . DIRECTORY_SEPARATOR . &lsquo;library&rsquo;));
// добавляем путь к library к indlude path
set_include_path(implode(DIRECTORY_SEPARATOR, array(</p>

<pre><code>        realpath(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'library'),
        get_include_path()
    )));
</code></pre>

<p>// подключаем Автолоадер
require_once &lsquo;MVC/Autoload/Autoloader.php&rsquo;;</p>

<p>// регистрируем наш автолоадер
spl_autoload_register(array(&lsquo;MVC_Autoload_Autoloader&rsquo;, &lsquo;autoload&rsquo;));</p>

<p>// создаем инстант нашего &ldquo;Фронт Контроллера&rdquo;
// в кавычках он потому, что это вовсе не паттерн Фронт Контроллер )
$frontController = new MVC_FrontController($_SERVER);
// запускаем наше приложение
$frontController->run();
```</p>

<h3>папка library</h3>

<p>В данной папке будет пока две директории MVC и Smarty, первая &ndash; это наш фреймворк, вторая как вы уже догадались &ndash; шаблонизатор :)</p>

<p>Рассмотрим поподробнее папку <strong>MVC</strong>
<strong>MVC_Autoload_Autoloader</strong></p>

<p>``` php
&lt;?php</p>

<p>class MVC_Autoload_Autoloader
{</p>

<pre><code>public static function autoload($className)
{
    // все как в ZF, чтобы отыскать класс заменяем в нем
  // '_' на '/'
    $className = str_replace('_', '/', $className);
    $classPath = LIBRARY_PATH . DIRECTORY_SEPARATOR . $className . '.php';
    if (file_exists($classPath) &amp;&amp; is_readable($classPath)) {
     // подключаем его, если файл имеется и мы имеем к нему доступ
        require_once $classPath;
    } else {
        //throw new MVC_Exception("Class name '{$className}' not found");
    }
    //echo $classPath;
}
</code></pre>

<p>   // тут я планировал указывать какие еще префиксы загружать автоматически</p>

<pre><code>public static function registerAutoload()
{

}
</code></pre>

<p>}
```</p>

<p><strong>MVC_Autoload_Resource</strong> &ndash; будет отвечать за подгрузку контроллеров, правда получился он не особо гибким и пути были жестко прописаны в код (очень не хорошо получилось).</p>

<p>``` php
&lt;?php</p>

<p>class MVC_Autoload_Resource
{
   // думал будет у меня несколько ресурсов
   // аля контроллеры, модели и прочие штуки</p>

<pre><code>protected static $_resources = array(
    'controller' =&gt; '@App_Controller_(\w+)Controller@',
);
</code></pre>

<p>   // метод без проверок, т.к. фреймворк создавался для ознакомительных целей</p>

<pre><code>public static function autoload($className)
{
  // пробегаемся по всем ресурсам
  // и смотрим на что заканчивает класс
    foreach(self::$_resources as $resource =&gt; $path) {
     // если на то, что нужно подгружаем его
        if (ucfirst($resource) == substr($className, -strlen($resource))) {
            if (preg_match(self::$_resources[$resource], $className, $matches)) {
                self::load($matches[1], $resource);
            }
        }
    }
}

protected static function load($name, $resourceType)
{
    switch ($resourceType) {
        case 'controller':
            require_once APPLICATION_PATH . DIRECTORY_SEPARATOR
                    . 'controllers' . DIRECTORY_SEPARATOR
                    . "{$name}Controller.php";


            break;

        default:
            break;
    }
}
</code></pre>

<p>}
```</p>

<h3>Стукрутра папок в приложении (App)</h3>

<p>3 папки: config, controllers, views
<strong>config</strong> &ndash; содержит на данный момент всего один файл с настройками приложения application.php</p>

<p>``` php
&lt;?php</p>

<p>$settings = array(</p>

<pre><code>'application' =&gt; array(
    'applicationName' =&gt; 'first application'
),
</code></pre>

<p>   // самое интересное, наверное, в этом фреймворке</p>

<pre><code>'routes' =&gt; array(
  // все рауты имеют имя, шаблон или регулярное выражение
  // контроллер, экшн и параметры
    'static' =&gt; array(
        'template' =&gt; '^(\w+)\.html$',
        'controller' =&gt; 'static',
        'action' =&gt; 'show',
        'params' =&gt; array(
            'name' =&gt; 1
        )
    ),
    'main' =&gt; array(
        'template' =&gt; null,
        'controller' =&gt; 'index',
        'action' =&gt; 'index'
    ),
    'dynamic' =&gt; array(
        'template' =&gt; '^(\w+)\/(\w+)$',
        'controller' =&gt; 'dynamic',
        'action' =&gt; 'show',
        'params' =&gt; array(
            'category' =&gt; 1,
            'article' =&gt; 2
        )
    )
),
'view' =&gt; array(
  // где будут лежать наши шаблоны (views)
    'viewPath' =&gt; APPLICATION_PATH . DIRECTORY_SEPARATOR . 'views',
  // имя нашего шаблона (layout)
    'template' =&gt; 'template.tpl'
)
</code></pre>

<p>);
```</p>

<p>Вскользь хочу упоминуть лишь некоторые классы
<strong>MVC_Registry</strong> &ndash; стандартный паттерн Registry без излишеств, нужен нам для того, чтобы хранить данные и предоставлять доступ к ним из любого места в приложении.</p>

<p><strong>MVC_Request</strong> &ndash; класс запроса, который мы строим в нашем &ldquo;Фронт контроллере&rdquo; и передаем в контроллеры приложения. Содержит параметры в запросе, активный контроллер и экшн.</p>

<p><strong>MVC_View</strong> &ndash; класс, который просто инициализует Smarty и устанавливает все нужные нам значения путей для шаблонов.</p>

<h3>&ldquo;Front Controller&rdquo;</h3>

<p>Этот класс &ndash; точка входа для нашего приложение, хоть и должен был он реализован быть как Одиночка (Singleton)</p>

<p><strong>MVC_FrontController</strong></p>

<p>``` php
&lt;?php</p>

<p>class MVC_FrontController
{</p>

<pre><code>protected $_routes;
protected $_settings;
protected $_controller;
protected $_action;
protected $_params;

public function __construct($request)
{
    $this-&gt;_initConfigs();
    $this-&gt;_initResources();
    $this-&gt;_initRoutes();
}

protected function _parseRequest()
{
    return $_SERVER['REQUEST_URI'];
}

public function run()
{
    $uri = $this-&gt;_parseRequest();

    $activeRoute = $this-&gt;_checkActiveRoute($uri);
    if (null === $activeRoute)
        throw new MVC_Exception('Cannot find active route');
    $this-&gt;_dispatch($activeRoute);

    $controllerName = sprintf('App_Controller_%sController', ucfirst($this-&gt;_controller));
    $controllerObj = new $controllerName(
                    new MVC_Request(
                            array('params' =&gt; $this-&gt;_params,
                                'controller' =&gt; $this-&gt;_controller,
                                'action' =&gt; $this-&gt;_action)
                    )
    );
    $methodName = $this-&gt;_action . 'Action';
    if (method_exists($controllerObj, $methodName)) {
        $controllerObj-&gt;$methodName();
        $controllerObj-&gt;render();
    } else {
        throw new MVC_Exception('action not found');
    }
}

protected function _initConfigs()
{

    require_once APPLICATION_PATH . DIRECTORY_SEPARATOR . 'config' . DIRECTORY_SEPARATOR . 'application.php';

    MVC_Registry::getInstance()-&gt;set('settings', $settings);
    $this-&gt;_settings = $settings;
}

/**
 * init resource autoloading
 */
protected function _initResources()
{
    spl_autoload_register(array('MVC_Autoload_Resource', 'autoload'));
}

/**
 * init routes
 */
protected function _initRoutes()
{
    if (isset($this-&gt;_settings['routes'])) {
        $this-&gt;_routes = $this-&gt;_settings['routes'];
    } else {
        throw new MVC_Exception('Routes must be specified');
    }
}

/**
 * get active route name
 *
 * @param string $uri
 * @return string active route name
 */
protected function _checkActiveRoute($uri)
{
    $uri = substr($uri, 1);
    if (trim($uri)) {
        $activeRoute = null;

        foreach($this-&gt;_routes as $name =&gt; $routeSettings) {
            if (!$routeSettings['template'])
                continue;
            if (preg_match('@' . $routeSettings['template'] . '@', $uri, $matches)) {
                if (isset($routeSettings['params'])) {
                    foreach($routeSettings['params'] as $paramName =&gt; $param) {
                        $this-&gt;_params[$paramName] = $matches[$param];
                    }
                }
                $activeRoute = $name;
            }
        }
    } else {
        $activeRoute = 'main';
    }

    return $activeRoute;
}

/**
 * dispatch
 *
 * @param string $activeRoute active route name
 */
protected function _dispatch($activeRoute)
{
    if (isset($this-&gt;_routes[$activeRoute])) {
        $this-&gt;_controller = $this-&gt;_routes[$activeRoute]['controller'];
        $this-&gt;_action = $this-&gt;_routes[$activeRoute]['action'];
    }
}
</code></pre>

<p>}
```</p>

<p>Я старался комментировать не особо очевидные места, но если возникнут вопросы, обязательно задавайте их в комментериях внизу заметки. Метод _checkActiveRoute() определяет в зависимости от REQUEST_URI активный раут. И заполняет параметры для контроллера нашего приложения.</p>

<p>Метод _dispatch() по активному рауту определяет нужный в данный момент контроллер и экшн.</p>

<p>Метод run() запускает наш контроллер, передавая ему объект запроса с нужными нам параметрами. После запуска нужного экшна мы запускаем метод контроллера render() который и выводит контент.</p>

<h3>MVC_Controller_Abstract</h3>

<p>Этот класс раширяют все контроллеры нашего приложения, единственный метод, на котором стоит заостроить внимание это render()</p>

<p>``` php
public function render()</p>

<pre><code>{
    $templatePath = $this-&gt;_view-&gt;template_dir . DIRECTORY_SEPARATOR;
    $templatePath .= strtolower(
            $this-&gt;getRequest()-&gt;getController()
            . DIRECTORY_SEPARATOR
            . $this-&gt;getRequest()-&gt;getAction() . '.tpl'
    );
    if (file_exists($templatePath) &amp;&amp; is_readable($templatePath)) {
        $this-&gt;getView()-&gt;assign('tplName', $templatePath);

        if (null === $this-&gt;_view-&gt;template)
            $this-&gt;getView()-&gt;display('template.tpl');
        else {
            $this-&gt;getView()-&gt;display($this-&gt;getView()-&gt;template);
        }
    } else {
        throw new MVC_Exception("Template '{$templatePath}' not found");
    }
}
</code></pre>

<p>```</p>

<p>Допустим мы прошли по адресу example.com/ нашего приложения. Наш &ldquo;Фронт Контроллер&rdquo; запустит app/controllers/IndexController.php и метод indexAction(). В нем, к примеру, мы присвоим переменной name значение vredniy</p>

<p>``` php
public function indexAction()</p>

<pre><code>{
    $this-&gt;getView()-&gt;assign('name', 'Vredniy');
}
</code></pre>

<p>```</p>

<p>Дальше метод <strong>MVC_Controller_Abstract::render()</strong> отыщет наш шаблон (layout). В данном случает это, находящийся в папке app/views, файл template.tpl. Приведу его содержимое</p>

<p>``` html
<html></p>

<pre><code>&lt;head&gt;
    &lt;title&gt;title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;template&lt;/h1&gt;
    {include file="$tplName"}
    &lt;h2&gt;footer&lt;/h2&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<p>Это и есть основной шаблон для нашего приложения. Вы спросите, а как же тогда выводится переменная name, значение которой мы присваивали в IndexController::indexAction(). Все просто: встроенная конструкция Smarty {include file=&ldquo;$tplName&rdquo;} заменяется содержимым соответствующего экшна видом.
Метода render() в MVC_Controller_Abstract</p>

<p>``` php
$this->getView()&ndash;>assign(&lsquo;tplName&rsquo;, $templatePath);</p>

<p>```</p>

<p>Сам же вид экшна имеет вид</p>

<p>``` html
<b>{$name|upper}</b></p>

<h2>MAin page</h2>


<p>```</p>

<p><a href="/images/posts/2011-06-mvc-framework-php/php-mvc-project1.png"><img class="image" src="/images/posts/2011-06-mvc-framework-php/php-mvc-project1-300x168.png"></a></p>

<p>Вот вроде и все. Данный фреймворк не предназначен для построения сложных сайтов, да и вообще для сайтов. Да и вообще ни для чего он не предназначен, кроме понимания некоторых важных для любого фреймворка вещей. В данном ознакомительном фреймворке куча ошибок и недоработок, реализация или исправления которых могли существенно захломить тестовый фреймворк и намного усложнить его понимание.</p>

<p>Спасибо всем за внимание, надеюсь, хоть часть мною написанного вам пригодится. Ах да, чуть не забыл прилагаю к заметке ссылку на <a href="https://github.com/vredniy/simple-mvc">репозиторий</a>, чтобы вы смогли скачать данный фреймворк и запустить у себя.</p>

<p>UPDATE: Сегодня решил, что в связке MVC не может не быть модели, поэтому решил я ее сегодня дописать.</p>

<h3>Модель в MVC</h3>

<p>Добавил я два класса: первый это MVC_Db_Exception, чтобы выбрасывать эксепшны не просто MVC_Exception. Второй &ndash; освновной MVC_Db_Abstract, который мы будем расширять в модели. Приведу его код:</p>

<p>``` php
&lt;?php</p>

<p>class MVC_Db_Abstract
{</p>

<pre><code>/**
 * PDO object
 *
 * @var Pdo
 */
private $_connection;
/**
 * PDO options
 *
 * @var array
 */
protected $_options = array(PDO::MYSQL_ATTR_INIT_COMMAND =&gt; "SET NAMES 'UTF8'");

/**
 * PDO attributes
 *
 * @param array|string $attribs
 */
public function __construct()
{
    $this-&gt;_initConnection();
}
</code></pre>

<p>   // инициализуем соединение, если его еще нет</p>

<pre><code>private function _initConnection()
{
    if (!$this-&gt;_connection instanceof PDO) {
        $settings = MVC_Registry::get('settings');
        $dbSettings = $settings['database'];
        $dsn = sprintf('%s:host=%s;dbname=%s', $dbSettings['adapter'], $dbSettings['params']['host'], $dbSettings['params']['dbname']);
        try {
            $this-&gt;_connection = new PDO($dsn, $dbSettings['params']['username'], $dbSettings['params']['password'],
                            $this-&gt;_options);
        } catch (PDOException $e) {
            echo 'Connection failed: ' . $e-&gt;getMessage();
        }
    }
}
</code></pre>

<p>   // возвращаем соединение, которое и будем использовать в моделях</p>

<pre><code>public function getConnection()
{
    return $this-&gt;_connection;
}
</code></pre>

<p>}
```</p>

<p>И внимание, кто пробует это проделать по заметке, будьте внимательны, потому что я чуть дописал MVC_Autoload_Resource, чтобы он помимо контроллеров мог подгружать еще и наши модельки. Самая актуальная версия в <a href="https://github.com/vredniy/simple-mvc">репозитории</a>.</p>

<h3>Использование модели</h3>

<p>Создадим папку app/models, где и будут лежать наши модели. В ней создадим файл PageModel.php с таким содержимым</p>

<p>``` php
&lt;?php</p>

<p>class App_Model_PageModel extends MVC_Db_Abstract
{</p>

<pre><code>/**
 * get page id
 *
 * @param int
 */
public function getPage($id)
{
    $statementString = 'SELECT id, alias, content FROM pages WHERE %s = ?';
    if (is_int($id)) {
        $statementString = sprintf($statementString, 'id');
    } else {
        throw new MVC_Db_Exception('id must be int');
    }
    $statement = $this-&gt;getConnection()-&gt;prepare($statementString);
    $statement-&gt;execute(array($id));
    return $statement-&gt;fetch();
}
</code></pre>

<p>}
```</p>

<p>Данная модель умеет извлекать из таблицы pages нужные нам данные с помощью PHP Data Object (PHP) по id. Дамп базы данных я выложил в репозитории в папке data/dumps</p>

<p>Теперь в контроллере попробуем использовать нашу модель. Я взял для примера IndexController, в index экшн которого я дописал следующее.</p>

<p>``` php</p>

<pre><code>public function indexAction()
{
  // создаем нашу модель
    $model = new App_Model_PageModel();
  // извлекаем из нее нужные нам данные и
  // отдаем их Smarty, т.е. во View
    $this-&gt;getView()-&gt;assign('data', $model-&gt;getPage(1));
    $this-&gt;getView()-&gt;assign('name', 'Vredniy');
}
</code></pre>

<p>```</p>

<p>В шаблоне views/index/index.tpl я добавил три строчки, которые и будут выводить содержимое:</p>

<p>``` html
<b>{$name|upper}</b></p>

<h2>{$data.alias}</h2>


<p>{$data.content}
```</p>

<p>Вот вроде и все, еще раз удачи вам :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Модели, Doctrine и Zend Framework]]></title>
    <link href="http://zudochkin.ru/2010/11/mvc-models-doctrine-zend-framework"/>
    <updated>2010-11-27T21:02:20+03:00</updated>
    <id>http://zudochkin.ru/2010/11/mvc-models-doctrine-zend-framework</id>
    <content type="html"><![CDATA[<p>Давайте напишем пару слов о популярном сейчас ORM Doctrine, научимся устанавливать его, использовать в своих проектах наряду с Zend Framework'ом.</p>

<!-- more -->


<p><a href="/images/posts/2010-11-mvc-models-doctrine-zend-framework/zend-framework-doctrine1.jpg"><img class="image" src="/images/posts/2010-11-mvc-models-doctrine-zend-framework/zend-framework-doctrine1-150x150.jpg"></a></p>

<h3>Установка Doctrine</h3>

<p>  В первую очередь скачиваем с официального сайта <a href="http://www.doctrine-project.org/projects/orm/download">Doctrine</a>, я свое ознакомление начал со стабильной версии 1.2, хотя для скачивания доступна вторая версия (бета), думаю ее &ldquo;пощупаю&rdquo; немного попозже. Распаковываем ее и копируем папку lib из Doctrine-* в include_path, я поместил ее в /usr/share/php/. Теперь напишем первый скрипт, который проверит работу Doctrine. Хотя подождите, подготовим сначала базу данных и наполним ее данными для тестов. За неимением лучшего я всего скачиваю mysql wordl database (на этот раз это будет innoDB версия) по <a href="http://dev.mysql.com/doc/index-other.html">ссылке </a> и создаю пользователя для тестов с паролем и логином таким же, как и название базы данных. У меня получился пользователь world с паролем world и база данных тоже называется world, теперь приступим.</p>

<p>``` php
&lt;?php
  include_once &lsquo;Doctrine/Doctrine.php&rsquo;;</p>

<p>  // подключаем автозагрузку
  spl_autoload_register(array(&lsquo;Doctrine&rsquo;, &lsquo;autoload&rsquo;));</p>

<p>  $manager = Doctrine_Manager::getInstance();</p>

<p>  // подключаемся к базе данных
  $conn = $magager->connection(&lsquo;mysql://world:world@localhost/world&rsquo;, &lsquo;doctrine&rsquo;);</p>

<p>  // получаем список всех баз данных
  $databases = $conn->import->listDatabases();
  var_dump($databases);
?>
```</p>

<p>Дальше запускаем наш скрипт и видим, если все сделали правильно, список всех баз данных.</p>

<h3>Генерация моделей Doctrine</h3>

<p>Так как Doctrine идет в комплекте с мощным генератором моделей, который может &ldquo;читать&rdquo; существующую базу данных и создавать классы моделей. Чтобы увидеть это в действии, запустим  следующее.</p>

<p>``` php
&lt;?php
  include_once &lsquo;Doctrine/Doctrine.php&rsquo;;
  spl_autoload_register(array(&lsquo;Doctrine&rsquo;, &lsquo;autoload&rsquo;));</p>

<p>  $manager = Doctrine_Manager::getInstance();</p>

<p>  $conn = $manager->connection(&lsquo;mysql://world:world@localhost/world&rsquo;, &lsquo;doctrine&rsquo;);</p>

<p>  // генерируем модели в папке со скриптом
  // 2 параметр соединение, которое мы указывали на строчку выше
  // 3 префикс для названия файлов и классов
  Doctrine::generateModelsFromDb(&lsquo;./models&rsquo;,</p>

<pre><code>array('doctrine'),
array('classPrefix' =&gt; 'Model_', 'classPrefixFiles' =&gt; false)
</code></pre>

<p>  );
?></p>

<p>```</p>

<p>К сведению, Doctrine для каждой таблицы в базе данных создает 2 класса модели, базовый класс и класс-наследник. Базовый класс расширяет Doctrine_Record и включает определения таблицы и базовые операции по работе с таблицей. Класс-наследник &ndash; это место для написания дополнительного функционала, который мы собираемся добавить в модель.</p>

<p>Теперь скопируем все получившиеся модели (их должно получиться 6 штук) в наш Zend Framework проект в папку application/models.</p>

<h3>Настраиваем модельные связи</h3>

<p><a href="http://vredniy.ru/wp-content/uploads/2010/11/doctrine.png"><img class="image" src="/images/posts/2010-11-mvc-models-doctrine-zend-framework/doctrine-300x194.png"></a>
Doctrine &ndash; очень мощный ORM, но она не может справиться с установлением связей между таблицами, чем мы займемся сами. Doctrine поддерживает все виды связи один-к-одной, один-ко-многим, многие-ко-многим и рекурсивную используя всего 2 метода hasOne() и hasMany(). У каждого метода два аргумента: имя другой модели для объявления связи и массив опций, характеризующих связь. Для того, чтобы связи автоматически загружались поместим их в setUp() метод.</p>

<p><strong>models/City.php</strong></p>

<p>``` php
&lt;?php
  class Model_City extends Model_BaseCity
  {</p>

<pre><code>  public function setUp()
  {
 $this-&gt;hasOne('Model_Country', array(
     'local' =&gt; 'CountryCode',
     'foreign' =&gt; 'Code'
 ));
  }
</code></pre>

<p>  }
?>
```</p>

<p><strong>models/Country.php</strong></p>

<p>``` php
&lt;?php
  class Model_Country extends Model_BaseCountry
  {</p>

<pre><code>  public function setUp()
  {
 $this-&gt;hasOne('Model_City', array(
     'local' =&gt; 'Code',
     'foreign' =&gt; 'CountryCode'
 ));
 $this-&gt;hasOne('Model_CountryLanguage', array(
     'local' =&gt; 'Code',
     'foreign' =&gt; 'CountryCode'
 ));
  }
</code></pre>

<p>  }
?>
```</p>

<p><strong>models/CountryLanguage.php</strong></p>

<p>``` php
&lt;?php
  class Model_CountryLanguage extends Model_BaseCountryLanguage
  {</p>

<pre><code>  public function setUp()
  {
 $this-&gt;hasOne('Model_Country', array(
     'local' =&gt; 'CountryCode',
     'foreign' =&gt; 'Code'
 ));
  }
</code></pre>

<p>  }
?>
```</p>

<h3>Автозагрузка классов Doctrine в Zend Framework</h3>

<p>Все что осталось сделать, так это то, чтобы приложение Zend Framework и Doctrine хорошо жили совместно. В первую очередь поместим Doctrine в папку library Zend Framework'а. Следующая стадия &ndash; обновить конфигурационный файл application.ini, поместив туда строку DSN, чтобы Doctrine могла без проблем соединяться с базой данных. Допишем в [production] секцию</p>

<p><code>php
doctrine.dsn = "mysql://world:world@localhost/world"
</code></p>

<p>Финальным шагом для инициализации Doctrine напишем защищенный метод в нашем бутстрапе.
<strong>application/Bootstrap.php</strong></p>

<p>``` php
&lt;?php
class Bootstrap extends Zend_Application_Bootstrap_Bootstrap
{
  protected function _initDoctrine()
  {</p>

<pre><code>require_once 'Doctrine/Doctrine.php';
$this-&gt;getApplication()
-&gt;getAutoloader()
-&gt;pushAutoloader(array('Doctrine', 'autoload'), 'Doctrine');

$manager = Doctrine_Manager::getInstance();
$magager-&gt;setAttribute(
  Doctrine::ATTR_MODEL_LOADING, Doctrine::MODEL_LOADING_CONSERVATIVE
);

$config = $this-&gt;getOption('doctrine');
$conn = Doctrine_Manager::connection($config['dsn'], 'doctrine');
</code></pre>

<p>  }
}
?>
```</p>

<h3>Операции с моделью Doctrine</h3>

<p>До того, как погрузиться в кроличью, освоим элементарные операции с моделями.
Извлечение данных
&hellip; по ID:</p>

<p><code>php
&lt;?php
  $city = Doctrine::getTable('Model_City')-&gt;find(10);
  var_dump($city);
?&gt;
</code></p>

<p>&hellip; всех записей:</p>

<p><code>php
&lt;?php
  $cities = Doctrine::getTable('Model_City')-&gt;findAll();
  var_dump($cities);
?&gt;
</code></p>

<p>Также в Doctrine есть свой язык запросов DQL (Doctrine Query Language), который предоставляет гибкий интерфейс для создания и выполнения запросов. Посмотрим на примеры.</p>

<p>``` php
&lt;?php
  $query = Doctrine_Query::create()</p>

<pre><code>   -&gt;from('Model_City c');
</code></pre>

<p>  $result = $query->fetchArray();
?>
```</p>

<p>Использование условий</p>

<p>``` php
&lt;?php
  $query = Doctrine_Query::create()</p>

<pre><code>   -&gt;from('Model_City c');
   -&gt;where('c.id = ?', 10);
</code></pre>

<p>  $result = $query->fetchArray();
?>
```</p>

<p>В DQL много приятных плюшек, среди которых группировка и сортировка, но мы остановимся чуть подробнее на присоединении таблиц, для которого предусмотрены два метода leftJoin() и innerJoin(). А где же присоединение справа спросите вы, оно как считают разработчики не нужно, ведь можно так спроектировать запрос, чтобы присоединение справа не было нужно.</p>

<p>``` php
&lt;?php
  $query = Doctrine_Query::create()</p>

<pre><code>   -&gt;from('Catalog_Model_Country co')
   -&gt;leftJoin('co.Catalog_Model_City ci')
   -&gt;where('ci.id = ?', 10)
</code></pre>

<p>  $result = $query->execute();
?>
```</p>

<p>  Поля необходимые для соединения таблиц автоматически устанавливаются Doctrine, основываясь на связях, определенных в методе setUp модели.</p>

<blockquote><p>   Небольшой совет: используя DQL, иногда необходимо посмотреть что же там получилось, для этого и существует метод getSqlQuery(), который и возвращает сырой SQL.</p></blockquote>

<h3>Doctrine и CRUD</h3>

<p>Сейчас научимся элементарным операциям аля create, read, update и delete (CRUD).
Для добавление новой записи, вам необходимо создать экземпляр класса, заполнить все поля (свойства) и вызывать метод save(). Вот пример</p>

<p><code>php
&lt;?php
  $city = new Model_City();
  $city-&gt;Name = 'New City';
  $city-&gt;CountryCode = 'RUS';
  $city-&gt;District = 'New City';
  $city-&gt;Population = 1;
  $city-&gt;save();
?&gt;
</code></p>

<p>Изменим-ка что-нибудь в уже существующей записи. Для начала найдем ту, в которой и будем что-либо менять, затем сохраним, вызвав save() метод.</p>

<p><code>php
&lt;?php
  $city = Doctrine::getTable('Model_City')-&gt;find(10);
  $city-&gt;Name = 'Updated city';
  $city-&gt;save();
?&gt;
</code></p>

<p>Удалять записи также легко, как и создавать новые, только вместо save() нужно использовать delete().</p>

<h3>Вернемся к Zend Framework'у</h3>

<p>Чтобы закрепить знания, давайте попробуем все это дело привести в более приятный вид. Сделаем все это в IndexController, чтобы не плодить тестовых контроллеров. Вот его код.</p>

<p>``` php
&lt;?php
class IndexController extends Zend_Controller_Action
{
  public function init() {}</p>

<p>  public function showAction()
  {</p>

<pre><code>$filters = array(
  'id' =&gt; array('HtmlEntities', 'StripTags', 'StringTrim')
);

$validators = array(
  'id' =&gt; array('NotEmpty', 'Int')
);

$input = new Zend_Filter_Input(
  $filters,
  $validators,
  $this-&gt;getRequest()-&gt;getParam('id')
);

if ($input-&gt;isValid()) {
  $query = Doctrine_Query::create()
        -&gt;from('Model_Country co')
        -&gt;leftJoin('co.Model_City ci')
        -&gt;leftJoin('co.Model_CountryLanguage cl')
        -&gt;where('ci.id = ?', $input-&gt;id);

  $this-&gt;view-&gt;query = $query-&gt;getSql();
  $result = $query-&gt;fetchArray();
  if (count($result) == 1) {
 $this-&gt;view-&gt;item = $result[0];
  } else {
 throw new Zend_Controller_Action_Exception('Страница не найдена');
  }
} else {
  throw new Zend_Controller_Action_Exception('Неверный параметр');
}
</code></pre>

<p>  }
}
?>
```</p>

<p>И для этого дела приделаем способ отображение а-ля index/show.phtml</p>

<p>``` php
&lt;?php</p>

<table>
  <tr>
    <th>County name</th>
    <th>Continent</th>
    <th>Country population</th>
    <th>City name</th>
    <th>LAnguage</th>
  </tr>
  <tr>
    <td><?php echo $this->item['Name'] ?></td>
    <td><?php echo $this->item['Continent'] ?></td>
    <td><?php echo $this->item['Population'] ?></td>
    <td><?php echo $this->item['Model_City']['Name'] ?></td>
    <td><?php echo $this->item['CountryLanguage']['Language'] ?></td>
  </tr>
</table>


<p>?>
```</p>

<p>Теперь когда вы зайдете по адресу yourhost.local/index/show/id/10, вы увидите часть информации о нем.</p>

<p>Вот и подошла к концу очередная заметка на тему веб-программирования, так мне интересную, надеюсь, вам понравилось.</p>

<p>И кстати, если кто увидит ошибки, прошу сообщать, очень не уверен, что правильно расставил связи один-ко-многим и один-к-одному. Заранее благодарю откликнувшихся.</p>
]]></content>
  </entry>
  
</feed>
