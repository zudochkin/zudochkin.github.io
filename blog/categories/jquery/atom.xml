<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: jQuery | Записки Вредного программиста]]></title>
  <link href="http://zudochkin.ru/blog/categories/jquery/atom.xml" rel="self"/>
  <link href="http://zudochkin.ru/"/>
  <updated>2014-02-23T20:16:54+04:00</updated>
  <id>http://zudochkin.ru/</id>
  <author>
    <name><![CDATA[Зудочкин Дима]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails Полиморфная связь и TokenInput jQuery]]></title>
    <link href="http://zudochkin.ru/2012/04/polymorphic-relations-and-token-input-jquery"/>
    <updated>2012-04-18T23:26:02+04:00</updated>
    <id>http://zudochkin.ru/2012/04/polymorphic-relations-and-token-input-jquery</id>
    <content type="html"><![CDATA[<p>Представьте ситуацию, что у вас имеется некая модель, к которой вы хотите добавлять по средствам связей другие модели. Хорошо, когда данную связь можно описать обычным <strong>has_many</strong>, другое дело, когда нужно привязать разнородные модели, к примеру, у вас имеется модель вопросов, к которой нужно привязать город или страну <!-- more -->(не очень наглядный пример, вряд ли он вам в жизни встретится, но я поделюсь своим опытом).</p>

<p>Как вы, наверное, догадались, основным инструментом будет выступать ruby an rails. Из гемов будем использовать <strong>simple_form</strong> для удобного создания форм, <strong>inherited_resources</strong>, чтобы писать намного меньше кода в контроллерах (сейчас не представляю без этого гема жизни).</p>

<p>Также нам понадобится плагин для jQuery <a href="http://loopj.com/jquery-tokeninput/">tokenInput</a>, который будет отображать выпадающий список с autoComplete'ом, из которого мы сможем выбрать одно значение из стран или городов (список будет один).</p>

<h3>Реализация</h3>

<p>Начнем с контроллера <strong>QuestionableController</strong> (не очень, конечно, удачное название), который будет отдавать солянку из городов и стран с возможностю поиска.
``` ruby
class QuestionableController &lt; ApplicationController
  def index</p>

<pre><code>countries = Country.find(:all, conditions: ['name LIKE(?)', "%#{ params[:q]
cities = City.find(:all, conditions: ['name LIKE(?)', "%#{ params[:q] }%"])

@questionable = countries + cities

respond_to do |format|
  format.json { render }
end
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>Лучше вынести всю логику в модель, но данный пример создан исключительно для демонстрации. Что мы делаем в этом контроллере? Ищем страны и города, удовлетворяющих параметру <strong>q</strong> и заполняем инстанс переменную <strong>@questionable</strong></p>

<p>Также давайте заполним нашу вьюшку <em>index.json.erb</em></p>

<p>``` ruby
&lt;%= sanitize @questionable.to_json(methods: [:id_with_class_name], only: [:id, :name]) %></p>

<p>```</p>

<p>в которой мы рендерим наш json, т.к. нам не нужны все поля модели мы используем только необходимые <code>(only: [:id, :name])</code>, ключ methods: указывает на то, что мы помимо физических свойст, будем использовать метод модели <em>id_with_class_name</em>.</p>

<p>Пока не забыл, давайте пропишем пару строк в наш <em>config/routes.rb</em></p>

<p><code>ruby
resources :questions # для того, чтобы создавать/показывать/удалять вопросы
resources :questionable, only: :index # для того, чтобы отображать json
</code></p>

<p>Перейдем к моделям:</p>

<p><em>models/question.rb</em>
``` ruby
class Question &lt; ActiveRecord::Base
  attr_accessor :location</p>

<p>  belongs_to :questionable, polymorphic: true
  attr_accessible :name, :questionable_id, :questionable_type</p>

<p>  before_save do</p>

<pre><code>return unless self.location =~ /_/
location_id, location_type = self.location.split('_')
self.questionable_id   = location_id   unless location_id.nil?
self.questionable_type = location_type unless location_type.nil?
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>Самая интересная строчка &ndash; это та, которая начинается с <code>belongs_to</code>, в ней мы объявляем полиморфную связь questionable. Дальше идет метод, который мы вызываем каждый раз перед сохранением в базу данных. В нем мы парсим строку из autoComplete'а, которая будет иметь вид id_ModelName и сохраняем отдельно id и ModelName.</p>

<p>Модель <em>city.rb</em>
``` ruby
class City &lt; ActiveRecord::Base
  has_many :questions, as: :questionable
  attr_accessible :name</p>

<p>  def id_with_class_name</p>

<pre><code>"#{ id }_#{ self.class.name }"
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>В ней объявляется связь <code>has_many</code> через questionable, который мы обявили в модели question полиморфной. Далее идем метод, который возвращает id записи и название класса модели (чтобы можно было отделить зерно от плевел).</p>

<p>Модель <em>country.rb</em> почти такая же
``` ruby
class Country &lt; ActiveRecord::Base
  has_many :questions, as: :questionable
  attr_accessible :name</p>

<p>  def id_with_class_name</p>

<pre><code>"#{ id }_#{ self.class.name }"
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>Связь обявлена также как и в предыдущей модели.</p>

<p>Наш маленький контроллер <em>QuestionController</em>
<code>ruby
class QuestionsController &lt; InheritedResources::Base
end
</code>
где остальное спросите вы. Это все. Это все, что нам нужно для того, чтобы создавать, удалять, редактировать вопросы. Как вы, наверное, заметили наш контроллер наследуется не от ApplicationController'а, а от inherited_resources. Что это значит? А это значит, если абстрагироваться от 80% возможностей этого гема, то, что гем берет всю &ldquo;грязную&rdquo; работу на себя, предоставляя нам в пользование переменные resource и collection, хранятся в которых ссылка на текущую запись (resource) и список всех записей (collection) соответственно. Для того, чтобы мы смогли создать свой первый вопрос нам необходимы лишь вьюшки. Начнем с _form.html.erb, которую мы будем подключать и в создании вопроса, и в редактировании.</p>

<p><em>app/views/questions/</em>form.html.erb_</p>

<p>``` ruby
&lt;%= simple_form_for resource do |f| %>
  &lt;% pre = if resource.questionable %></p>

<pre><code>&lt;% [resource.questionable].to_json(only: [:id, :name]) %&gt;
</code></pre>

<p>  &lt;% end %>
  &lt;%= f.input :name %>
  &lt;%= f.input :location, input_html: { &lsquo;data-pre&rsquo; => pre, class: &lsquo;token-input-questionable&rsquo; } %>
  &lt;%= f.submit nil %>
&lt;% end %></p>

<p>```</p>

<p>Как видите, почти никаких различий с нативным form_for нет. Во второй строке мы заполняем переменную pre json'ом выбранного города или страны, в предпоследней создаем инпут с атрибутом data-pre, равным json'у и классом, чтобы мы могли найти этот элемент без проблем.</p>

<p><em>new.html.erb</em> и <em>edit.html.erb</em> абсолютно одинаковы и представляют собой следующее:</p>

<p><code>ruby
&lt;%= render 'form' %&gt;
</code></p>

<p>в них мы отрисовываем только форму.</p>

<p>Далее кинем наш скачанный jquery.tokeninput.js в папку <em>app/assets/javascripts</em> и допишем в <em>application.js</em> следующее:</p>

<p>``` javascript
$(function() {
  var $input = $(&lsquo;.token-input-questionable&rsquo;);
   $input.tokenInput(&lsquo;/questionable.json&rsquo;, {</p>

<pre><code>  tokenLimit: 1,
  tokenValue: 'id_with_class_name',
  prePopulate: $input.data('pre')
});
</code></pre>

<p>});</p>

<p>```</p>

<p>Первым параметром к tokenInput мы указываем откуда брать данные, tokenLimit:1 указывает на то, что одной записи нам будет достаточно (одного элемента из выпадающего списка), tokenValue &ndash; откуда мы будем брать имя, которое будем отображать из json'а, prePopulate используем для того, чтобы заполнить элемент, если мы его уже выбрали (редактирование).</p>

<p><img class="image" src="/images/posts/2012-04-polymorphic-relations-and-token-input-jquery/rsz_1screenshot_from_2012-04-18_230555-300x209.png"></p>

<p>Сумбурным получилось изложения материала, потому что для меня это в новинку и писалось это для того, чтобы не забыть полезную &ldquo;плюшку&rdquo; в дальнейшем. Если заметка кому-нибудь еще пригодится, я буду очень рад :)</p>

<p>P.S.: Если данную заметку читает Александр, мало ли, то, надеюсь, он будет не против, что я позаимствовал его идею :)</p>

<p>Демо проект &ldquo;лежит&rdquo; на <a href="http://vredniy-polymorphic.heroku.com/questions/">heroku</a>, репозиторий, как всегда на <a href="https://github.com/vredniy/rails-token-input">github</a> (там же лежат и миграции, нужные для запуска проекта).</p>

<p>Удачи вам в любых начинаниях и до новых встреч :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backbone.js и Sinatra (Ruby)]]></title>
    <link href="http://zudochkin.ru/2012/02/backbone-js-sinatra-ruby"/>
    <updated>2012-02-11T23:58:01+04:00</updated>
    <id>http://zudochkin.ru/2012/02/backbone-js-sinatra-ruby</id>
    <content type="html"><![CDATA[<p>Приветствую тебя, товарищ-разработчик, сегодня речь пойдет больше о клиентсом программировании, точнее об одном фреймворке. Backbone js ему название. Что в нем особенного спросите вы. Это первый MVC фреймворк на стороне клиента, попавшийся мне на глаза. Очень долго я с ним воевал, поэтому тут уж дело чести понять как работают 1200 строк кода на javascript.</p>

<!-- more -->


<p>Данная заметка не прендует на всеобъемлющее описание, да и практической пользы от разрабатываемого в ней приложения (без доработки) практически нет, это больше для души или, как говорится, for fun.</p>

<p>Сначала поставим себе небольшую цель, чего же мы хотим увидеть по окончании: одна страница, без ссылок и переходов, все взаимодействие с сервером происходит в режиме реального времени по средством ajax запросов. В конце мы сможем добавлять новые книги, удалять их и изменять поля. Весь &ldquo;дизайн&rdquo; выполнен человеком, то бишь мною, ничего общего с дизайнерами и верстальщиками не имеющего, но, как мне кажется, он [дизайн], получился удобным и не отталкивающим. Обрабатывать наши ajax запросы будет Ruby при помощи замечательного фреймворка Sinatra, но работа им предстоит не сложная, поэтому сосредоточимся на frontend'е.</p>

<h3>Что еще за backbone.js?</h3>

<p>Аналог jquery? Нет, у данного фреймворка совсем другая специализация &ndash; его основная задача создать основу для модульного приложения на стороне клиента, чтобы богатые на компоненты и модули интерфейсы легко могли взаимодействовать с пользователем. Чтобы добавления новой функциональности не превращало код приложения в спагетти, а наоборот, этому способствовало.</p>

<h3>Из чего состоит backbone.js?</h3>

<p>Модель, Представление, Коллекция и Роутер, если не сильно вдаваться в подробности (очень хорошая документация собрана на сайте backbone.js), то модель представляет собой, если проводить аналогию с базами данных, строку в таблице, к любым свойствам которой мы легко можем обращаться, также легко мы можем ее обновлять, сохранять и прочее. Коллекция &ndash; кучка моделей или по аналогии &ndash; несколькими строками таблицы, объединенных общими полями и свойствами. Представление &ndash; вот это, по-моему, самая интересная и в то же время непростая для меня часть. Представление в понимании создателей backbone.js &ndash; это совсем иное, нежели мы, backend-разработчики привыкли видеть. Это что-то очень похожее на букву V из аббревиатуры MVC, но с немного большими возможностями и ответственностями. Я думаю на примере станет немного яснее. И последним будет Роутер &ndash; в данном приложении я его использовать не буду, оно слишком маленькое, чтобы усложнять его и без того не простую к пониманию новую технологию, по крайней мере, для меня. Как написано на сайте backbone.js роутер предоставляет методы для связывания ссылок на странице со всевозможными событиями. С появлением в нашей жизни History API, появилась возможность использовать наряду с ссылками вида /#about, ссылки обычного вида, /about, к примеру, что намного приятнее для глаза человеческого.</p>

<p><img class="image" src="/images/posts/2012-02-backbone-js-sinatra-ruby/backbone-sinatra.jpeg"></p>

<p>Итак, хватит воды, давайте приступим к делу. Начнем, конечно же с html, который и будет подключать все библиотеки стили на стороне клиента, в нем же будем хранить наш шаблон, что для маленького приложения не будет грубой ошибкой.</p>

<p>``` html</p>

<script type="text/javascript" src="js/jquery-1.7.1.js"></script>


<script type="text/javascript" src="js/underscore.js"></script>


<script type="text/javascript" src="js/backbone.js"></script>


<p><link rel="stylesheet" type="text/css" href="styles/bootstrap.css">
<link rel="stylesheet" type="text/css" href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/themes/hot-sneaks/jquery-ui.css">
<link rel="stylesheet" type="text/css" href="styles/main.css"></p>

<script type="text/javascript" src="js/bootstrap.js"></script>


<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/jquery-ui.min.js"></script>


<script type="text/javascript" src="js/jquery.ui.datepicker-ru.js"></script>


<!--<script type="text/javascript" src="js/backbone.localStorage.js"></script>-->


<p>```</p>

<p>Начнем с подключения библиотеки и стилей: за основу взят, уже не в первый раз css фреймворк bootstrap от twitter, в самом начале подключаем нашу любимую библиотеки <a href="/category/jquery">Query</a>, но backbone.js может работать и без нее, это больше для нас, чтобы вместо 5 строк не писать 50 :). underscore.js &ndash; библиотека-утилита, которая предоставляет основу для функционального программирования на JavaScript, без него не работает наш backbone.js, поэтому подключайте underscore.js раньше. Остальные библиотеки не должны вызвать сложностей в понимании: они уже у всех на слуху, отдельно коснусь закомментированной строки. Если ее расскомментировать и внести небольшие изменения в код, то вместо хранения всего в базе данных, мы будем использовать localStorage браузера, который это поддерживает.</p>

<p>Теперь немного разметки,</p>

<p>``` html</p>

<div class="container-fluid" id="books">
  <div class="row-fluid">
   <div class="span12">
      <h1>Моя библиотека</h1>
   </div>
  </div>
  <div class="row-fluid">
    <div class="span2">
      <div id="book-control">
         <!-- добавление новых книг -->
         <h3>Добавить</h3>

      <label for="book-title">Название книги</label>
      <input type="text" id="book-title" class="span12">
      <button class="btn-primary">Добавить новую</button>

   </div>
    </div>
    <div class="span8 book-container">
      <!-- место для книг -->
    </div>
    <div class="span2">
      <h3>Описание</h3>
    </div>
  </div>
</div>


<p>```</p>

<p>Здесь ничего особенного, поэтому не буду комментрировать.</p>

<p>Самое время привнести в наш проект немного магии, которое будет не мало. Первая магия &ndash; шаблоны на стороне клиента.</p>

<p>``` html</p>

<script type="text/template" id="book-template">
   <dl>
      <dt><a href="#" class="book-edit">Название:</a> <i class="icon-remove book-delete"></i></dt>
      <dd><input type="text" class="book-title"><span><%= title %></span></dd>

      <dt>Год издания: </dt>
      <dd><input type="text" class="book-year span3"><span><%= year %></span></dd>

      <dt>Автор: </dt>
      <dd><input type="text" class="book-author"><span><%= author %></span></dd>

      <dt>Жанр: </dt>
      <dd><input type="text" class="book-genre"><span><%= genre %></span></dd>

      <dt>ISBN: </dt>
      <dd><input type="text" class="book-isbn"><span><%= isbn %></span></dd>

      <dt>Статус: </dt>
      <dd>
         <select class="book-status">
            <option value="read">Прочитана</option>
            <option value="not-read">Не прочитана</option>
            <option value="want-read">Хочу прочитать</option>
         </select>
         <span><%= status %></span>
      </dd>
      <dt>Дата: </dt>
      <dd><input type="text" class="datepicker book-date"><span><%= date %></span></dd>

   </dl>
   <a class="btn btn-primary book-save">Сохранить</a>
</script>


<p>```</p>

<p>Казалось бы так похож на erb, но это просто совпадение, или разработчики данного шаблона рубисты. Вместо конструкций вида &lt;%= title %> в конечном html, появятся наши переменные, нам их нужно будет лишь заполнить. А верстка останется неизменной, что очень удобно.</p>

<p>Почти все, кроме одной строки, хотя эта одна строчка подключает сердце нашего приложения</p>

<p>``` html</p>

<script type="text/javascript" src="js/application.js"></script>


<p>```</p>

<p>Теперь самое время окунуться с головой в клиентское программирование (файл js/application.js).</p>

<p>Начнем, пожалуй, с модели.</p>

<p>``` javascript
var Book = Backbone.Model.extend({</p>

<pre><code>defaults: {
    title: "Book's title",
    year: 2009,
    author: "Murakami",
    genre: ["horror", "comedy"],
    isbn: "0128127622",
    status: "not read",
    image: "/images/placeholder.png",
    date: ''
},
</code></pre>

<p>});
```</p>

<p>Все модели нашего приложения должны расширять базовый класс Backbone.Model, свойство defaults, как понятно из названия отвечает за установку свойств модели по умолчанию. Я взял для примеры стандартные книжные свойства, большая часть из которых работает не до конца.</p>

<p>Теперь перейдем непосредственно к нашей библиотеке, расширив класс коллекции Backbone.Collection</p>

<p>``` javascript
var Library = Backbone.Collection.extend({</p>

<pre><code>//localStorage: new Store("BackboneCollection"),
url: '/books',
model: Book,
</code></pre>

<p>});
```</p>

<p>Закомментированная строка сохраняла бы всю нашу работу в local Storage браузера, мы же будем взаимодействовать с сервером, для этого нам понадобится адрес, по которому и будет производиться все общение (точнее будет основой для производных адресов). Последняя строка указывает коллекция каких объектов нами будет использоваться.</p>

<p>Если для модели нам не нужен объект, то для коллекции пригодится, поэтому создадим его.</p>

<p><code>javascript
var library = new Library();
</code></p>

<p>А сейчас начнется самое интересное &ndash; Представление. Будем разбирать его неспеша, чтобы ничего важного не упустить.</p>

<p>``` javascript
var BookView = Backbone.View.extend({</p>

<pre><code>    tagName: 'div',
    className: 'book',

    template: _.template($('#book-template').html()),

    events: {
        "click a.book-edit": "edit",
        "keypress input": "update",
        "click .book-delete": "clear",
        "click .book-save": "close",
    },
</code></pre>

<p>```</p>

<p>Сначала расширяем базовый класс Backbone.View, далее указываем элемент, с которым мы будем работать, в данном случае, это div с классом book. Следующая строка указывает какой шаблон мы будем рендерить и сохраняет его в переменной. В свойстве events мы перечисляем какие события мы будет &ldquo;прослушивать&rdquo;.
Каждая строка состоит из следующих моментов: сначала идет событие, которое мы будем обрабатывать, дальше &ndash; элемент, с которым это событие произойдет, после двоеточия &ndash; имя метода, который будет вызываться при наступлении прослушиваемого события.</p>

<p>Первая строка &ndash; нажимаем на ссылку &ndash; редактирование книги, вторая &ndash; нажимаем на кнопку (в указанном методе мы проверям Enter ли это) в текстовом поле &ndash; сохранить изменения. И последние две &ndash; это удаление и сохранение изменений.</p>

<p>Теперь опишим все методы нашего представления</p>

<p>``` javascript
initialize: function() {</p>

<pre><code>this.model.bind('change', this.render, this);
this.model.bind('destroy', this.remove, this);
</code></pre>

<p>},</p>

<p>update: function(e) {</p>

<pre><code>if (e.keyCode == 13) this.close();
</code></pre>

<p>},</p>

<p>close: function() {</p>

<pre><code>this.model.set(this._get());
this.model.save(this.model.toJSON());
    $(this.el).removeClass("editing");
</code></pre>

<p>},
```</p>

<p>Первым не важно для модели, коллекции или представления вызывается метод initialize, поэтому можно расценивать его как конструктор.</p>

<p>this.model будет во время работы приложения указывать на текущую модель, т.е. каждый кусок разметки будет связан с отдельной моделью, изменения в котором коснутся только одной модели, также как и наоборот. Первым делом мы связывем события модели с методами: первое это изменение модели, после которого должно произойти &ldquo;отрисовка&rdquo;, второе &ndash; удаление.</p>

<p>Метод <em>update</em> вызывается каждый раз, когда пользователь нажимает на клавиатуру, нам нужно отлавливать только нажатие Enter, чтобы сохранить изменения.</p>

<p>Метод <em>close</em> вызывается, когда пользователь нажал Enter или кликнул по кнопке &ldquo;Сохранить&rdquo;, посмотрите еще раз на последнюю строку из свойства events. В первой строке которого мы обновляем нашей модели свойств из текстовых полей. Дальше мы сохраняем модель и удаляем с себя класс редактирования (нужно будет для &ldquo;рюшечек&rdquo;).</p>

<p>Следующий метод, наверное, самый значимый, он отрисовывает все изменения модели на экране пользователя.</p>

<p>``` javascript
render: function() {</p>

<pre><code>$(this.el).html(this.template(this.model.toJSON()));
$(this.el).css({'background': ' no-repeat url(' + this.model.get('image') + ')'});
this.setText();
return this;
</code></pre>

<p>},
```</p>

<p><em>this.el</em> ни что иное, как tagName: &lsquo;div&rsquo; и className: &lsquo;book&rsquo;. Первая строка данного метода изменяет html элемента, учитывая новые свойства модели и учитывая разметку из шаблона. (Помните, мы писали недавно template: _.template($(&lsquo;#book-template&rsquo;).html())). Вторая строка данного метода заполняет фоновой картинкой наш кусок разметки.</p>

<p>&ldquo;Толстые&rdquo; методы для обновления свойств модели, исходя из значения текстовых полей или наоборот &ndash; текстоых полей, исходя их свойств модели.</p>

<p>``` javascript
setText: function() {</p>

<pre><code>var text = this.model.get('title');
this.$('.book span.book-title').text(text);
this.inputTitle = this.$('input.book-title');
this.inputYear = this.$('input.book-year');
this.inputAuthor = this.$('input.book-author');
this.inputGenre = this.$('input.book-genre');
this.inputIsbn = this.$('input.book-isbn');
this.inputStatus = this.$('select.book-status');
this.inputDate = this.$('input.book-date');
</code></pre>

<p>},
_fillForm: function() {</p>

<pre><code>var data = this.model.toJSON();
this.inputTitle.val(data.title);
this.inputYear.val(data.year);
this.inputAuthor.val(data.author);
this.inputGenre.val(data.genre);
this.inputIsbn.val(data.isbn);
this.inputStatus.val(data.status);
this.inputDate.val(data.date);
</code></pre>

<p>},</p>

<p>_get: function() {</p>

<pre><code>return {
    title: this.inputTitle.val(),
    year: this.inputYear.val(),
    author: this.inputAuthor.val(),
    genre: this.inputGenre.val(),
    isbn: this.inputIsbn.val(),
    status: this.inputStatus.val(),
    date: this.inputDate.val()
}
</code></pre>

<p>},
```</p>

<p>И последние 3 методя для данного представления:</p>

<p>``` javascript
edit: function() {</p>

<pre><code>$('div.book').removeClass('editing');
$(this.el).addClass('editing').find('input, select').fadeIn('slow');
this._fillForm();
this.inputTitle.focus();
return false;
</code></pre>

<p>},</p>

<p>clear: function() {</p>

<pre><code>if (confirm("Вы уверены?")) {
    this.model.destroy();
}
</code></pre>

<p>},</p>

<p>remove: function() {</p>

<pre><code>$(this.el).fadeOut('slow', function() {$(this).remove()});
</code></pre>

<p>}
```</p>

<p>Первый &ndash; уделяет класс редактирования со всех книг и устанавливает на активной и заполняет форму значениями модели (данный метод вызывается, когда пользователь нажмет на ссылку для редактирования).</p>

<p>Второй &ndash; задает пользователю вопрос, при утвердительном ответа на который удаляет данную модель.</p>

<p>Третий &ndash; вызывается автоматически и удаляет элемент со страницы, а вызывается он из-за того, что мы в конструкторе написали следующее:
<code>javascript
this.model.bind('destroy', this.remove, this);
</code></p>

<p>Осталось рассмотреть последнее представление и можно смело переходить к легкому backend'у.</p>

<p>``` javascript
var AppView = Backbone.View.extend({</p>

<pre><code>el: $('#books'),

events: {
    "click button": "create",
    "keypress #book-title": "createOnEnter"
},

initialize: function() {
    this.input = this.$('#book-title');
    library.bind('add', this.addOne, this);
    library.bind('reset', this.addAll, this);
    library.bind('all', this.render, this);
    library.fetch();
},

render: function() {
},
</code></pre>

<p>```</p>

<p>Данное представление отвечает за создание новых книг и загрузку книг с сервера. Книга создается заполнением только лишь названия, дальше ее можно отредактировать и сохранить. В конструкторе данного представления мы связываем необходимые события коллекции с методами, которые будет вызываться при наступлении событий. <strong>library.fetch();</strong> &ndash; запрашивает с сервера все книги, чтобы потом их отобразить.</p>

<p>Почему метод рендеринга пустой? Потому что он нам тут не нужен, все отрисовывается в методе добавления новой книги, с него и начнем продолжение рассказа.</p>

<p>``` javascript
addOne: function(book) {</p>

<pre><code>    var view = new BookView({model: book});
    var content = view.render().el;
    $(content).hide();
    $('#books').find('.book-container').prepend(content);
    $(content).show(1000);
},

addAll: function() {
    library.each(this.addOne);
},

createOnEnter: function(e) {
    if (e.keyCode == 13) {
        this.create();
    }
},

create: function(e) {
    var text = this.input.val();
    library.create({title: text});
    this.input.val('');
}
</code></pre>

<p>});</p>

<p>//$(&lsquo;.book-date&rsquo;).datepicker({});
var appView = new AppView();
```</p>

<p>Метод addOne добавляет в верстку одну книгу, создавая соответствующее представление. Метод addAll &ndash; пробегается по все коллекции книг и по одной с помощью метода addOne добавляет книги в верстку. Метод create создает для нас книгу с заголовком, который мы укажем в текстовом поле.</p>

<p>Осталось только создать нам представление приложения и наслаждаться результатом, хотя сначала нужно реализовать backend. Но он будет очень простым, поэтому быстрее перейдем к нему.</p>

<h3>Backend на Ruby</h3>

<p>Сначала общие моменты: подключение необходимых гемов, задание дефолтного подключения для DataMapper'а и описание класса Книга:</p>

<p>``` ruby</p>

<h1>coding: utf-8</h1>

<p>  require &lsquo;sinatra&rsquo;
  require &lsquo;data_mapper&rsquo;
  require &lsquo;json&rsquo;</p>

<p>  DataMapper.setup(:default, ENV[&lsquo;DATABASE_URL&rsquo;] || &lsquo;sqlite:./db/books.db&rsquo;)</p>

<p>  class Book</p>

<pre><code>include DataMapper::Resource

property :id,           Serial
property :title,        String
property :year,         Integer
property :date,         Date
property :image,        String
property :author,       String
property :genre,        String
property :isbn,         String
property :status,       String

#belongs_to :user
</code></pre>

<p>  end</p>

<p>  DataMapper.finalize</p>

<p>  get &lsquo;/&rsquo; do</p>

<pre><code>File.read('./public/index.html')
</code></pre>

<p>  end
```</p>

<p>Главной страницей у нас будет статичный файл .html
Теперь давайте сделаем небольшую паузу и поговорим о том, как взаимодействует Backbone.js с серверной частью. Если заглянуть в исходники, то там мы увидим следующее:</p>

<p>``` javascript
 var methodMap = {</p>

<pre><code>'create': 'POST',
'update': 'PUT',
'delete': 'DELETE',
'read':   'GET'
</code></pre>

<p>  };
```</p>

<p>Т.е. стандартный RESTfull запрос. Не будем оттягивать кота за яйца, закончим уже кодить над этим проектом, тем более, что Sinatra легко может обработать подобные запросы.</p>

<p>``` ruby
  get &lsquo;/books&rsquo; do</p>

<pre><code>content_type :json
Book.all(:order =&gt; :id).to_json
</code></pre>

<p>  end</p>

<p>  post &lsquo;/books&rsquo; do</p>

<pre><code>data = JSON.parse(request.body.gets)
Book.create(:title =&gt; data['title']);
</code></pre>

<p>  end</p>

<p>  put &lsquo;/books/:id&rsquo; do</p>

<pre><code>data = JSON.parse(request.body.gets)
book = Book.get(params[:id])
result = book.update(
  :title =&gt; data['title'],
  :year =&gt; data['year'],
  :author =&gt; data['author'],
  :genre =&gt; data['genre'],
  :isbn =&gt; data['isbn'],
  :status =&gt; data['status'],
  :image =&gt; '/images/placeholder.png', #data['image'],
  :date =&gt; Time.now
)
"false" unless result
</code></pre>

<p>  end</p>

<p>  delete &lsquo;/books/:id&rsquo; do</p>

<pre><code>Book.get(params[:id]).destroy
</code></pre>

<p>  end
```</p>

<p>Здесь нет ничего сложного, если есть какие-то сложности, посмотрите мои предыдущие заметки о Ruby и о Sinatra.</p>

<h3>Заключение</h3>

<p>Еще одно приложение мы разработали с вами на ruby, сегодня не обошлось без так важного на сегодняший день клиентсткого программирования. Ссылка на <a href="http://vredniy-library.heroku.com/">пример</a> (редактирование и создание не сохраняются в базе)  и ссылка на <a href="https://github.com/vredniy/Backbone-sinatra">исходник</a>.
<img class="image" src="/images/posts/2012-02-backbone-js-sinatra-ruby/placeholder.png">
Всем спасибо за внимание и до новых встреч :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sinatra и Whois gem: маленькое приложение]]></title>
    <link href="http://zudochkin.ru/2011/11/ruby-sinatra-whois"/>
    <updated>2011-11-18T02:26:34+04:00</updated>
    <id>http://zudochkin.ru/2011/11/ruby-sinatra-whois</id>
    <content type="html"><![CDATA[<p>Здравствуйте, уважаемые коллеги и те, кто может случайно забрел на мой блог. Сегодня речь пойдет о Ruby, но я не буду вдаваться в подробное описание языка, поэтому ограничимся базовой функциональностью замечательного фреймворка Sinatra.</p>

<!-- more -->


<h3>Вступление</h3>

<p>Мой отпуск подходит плавно к концу, но чтобы не зря тратить время решил я посвятить его изучению нового для меня языка программирования. Почему Ruby, возможно назреет у вас вопрос. Отвечу так: я долго шел к смене языка программировани, нет, это не из-за того, что мне не нравится PHP, отнюдь, но захотелось чего-то другого во время отпуска, тем более, что время позволяет. Прежде чем остановиться на Ruby, мною было прочитано много килобайт материала, просмотрено много мегабайт видео презентаций и скринкастов, и я решил более не задаваться глупыми вопросами, а может Python, может еще что-нибудь, решил просто попробовать.</p>

<p><img class="image" src="/images/posts/2011-11-ruby-sinatra-whois/ruby-sinatra-300x197.png">Почему Sinatra, а не Rails? Все просто: чтобы понять как работает такой большой веб-фреймворк, как Rails, понадобится намного больше времени, да и понять его без хорошего знания Ruby, я не рискну, а Sinatra в этом отношении в разы полегче, можно сказать, что это чистый Ruby.</p>

<h3>Постановка задачи</h3>

<p>Задача будет проста до безумия: у нас будет иметься одна страница с одним текстовым полем. Если мы введем туда корректное имя домена, приложение ответит нам доступен ли домен для регистрации и срок истечения, если домен зарегистрирован.</p>

<h3>Используемый инструментарий</h3>

<p>В первую очередь нам, конечно же, понадобится сервер с установленным на нем Ruby, локальный вполне подойдет. В этой короткой заметке я не буду рассказывать как его [сервер] установить, в интернете полным-полно подобных мануалов и раскрывают они тему исчерпывающе. В дополнение к гему sinatra, нам также понадобятся: whois (http://goo.gl/0jEJA) и гем json (им мы будем отдавать ответ).</p>

<h3>Реализация</h3>

<p>Приложение у нас будет состоять из двух экшнов: первый это главная страница, на которой и будет отображаться текстовый элемент и экшн, который будет отвечать за прием данных по средством AJAX, отправку запроса серверу whois и возвращению ответ в формате JSON.
Шаблонизатором у нас будет выступать HAML, очень удобная и простая штука, так что приведу код шаблона главной страницы в формате haml.</p>

<p>``` ruby
!!!
%html
  %head</p>

<pre><code>%meta{:content =&gt; "text/html; charset=UTF-8", "http-equiv" =&gt; "content-type"}/
%script{:type =&gt; 'text/javascript', :src =&gt; 'http://yandex.st/jquery/1.7.0/jquery.min.js'}
%script{:type =&gt; 'text/javascript', :src =&gt; '/javascripts/default.js'}
%title Маленькое приложение на Руби (Sinatra, Whois, Json)
</code></pre>

<p>  %body</p>

<pre><code>%div
  %p Впишите какой-нибудь, желательно, корректный домен и нажмите Enter
  %form{:method =&gt; 'post', :action =&gt; '/ajax.json'}
    %input{:type =&gt; "text", :name =&gt; "domain"}
  %ul{:id =&gt; 'info'}
</code></pre>

<p>```</p>

<p>Также приведу исходных код экшна главной страницы, который занимает всего 1 строчку. Его задача только отобразить шаблон.</p>

<p><code>ruby
get '/' do
   haml :index
end
</code></p>

<p>Наш AJAX экшн будет срабатывать по POST запросу при отсылке данных по адресу /ajax.json</p>

<p>``` ruby
  post &lsquo;/ajax.json&rsquo; do</p>

<pre><code>domain = params[:domain]

begin
  info = Whois.query(domain)
rescue Whois::ServerNotFound
end
content_type :json

{ :domain =&gt; domain, :info =&gt; {:available =&gt; info.available?, :registered =&gt; info.registered?, :expires =&gt; info.expires_on} }.to_json unless info.nil?
</code></pre>

<p>  end
```</p>

<p>В первой строке которого мы получаем имя домена через форму. Далее получаем необходимую информацию о домене, для того чтобы не сыпались в приложении исключения я оборачиваю вызов кода, который легко может выбросить исключения в обертку аля PHP try-catch. <strong>content_type json</strong>, как вы догадались, устанавливает формат ответа. В последней строке мы формируем JSON. Что удобно в Ruby, так это то, что не нужно возвращать значения, данный язык делает это сам, т.е. последняя строка в методе возвращает значение.</p>

<p>Осталось только связать нашу форму на главной странице и AJAX экшн. Для этих целей очень хорошо подойдет несколько строк на замечательном JavaScript-фреймворке jQuery. Задача &ndash; отправить AJAX запрос методом POST, дождаться ответа от сервера и заполнить список полями из полученного JSON.</p>

<p>``` javascript
$(function() {
  $(&lsquo;form&rsquo;).submit(function() {</p>

<pre><code>$.post('/ajax.json', $(this).serialize(), function(data) {
  if (!data) {
    alert('Что-то пошло не так (');
    return;
  }
  $('ul#info &gt; *').remove();
  $.each(data.info, function(field, value) {
    $('ul#info').append('
</code></pre>

<ul>
<li><strong>&lsquo; + field + &rsquo;</strong> &lsquo; + value + &rsquo;
&lsquo;)
    });
    console.log(data);
  }, 'json&rsquo;);
  return false;
});
});
```</li>
</ul>


<h3>Исходный код</h3>

<p>Исходный код вы можете посмотреть на гитхабе, <a href="https://github.com/vredniy/sinatra-whois">здесь</a>.</p>

<h3>Заключение</h3>

<p>Это была моя первая заметка на тему Ruby, надеюсь, мой блог и дальше будет пополняться подобными постами, потому что язык мне очень нравится, нравится своей гибкостью и необычностью (как программист на PHP говорю). Спасибо зв внимание и до новых встреч.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Общие заблуждения о jQuery (часть 1) parent, parents, closest]]></title>
    <link href="http://zudochkin.ru/2011/06/jquery-for-beginners-confusing-part1"/>
    <updated>2011-06-07T11:43:34+04:00</updated>
    <id>http://zudochkin.ru/2011/06/jquery-for-beginners-confusing-part1</id>
    <content type="html"><![CDATA[<p>Быстрый рост JavaScript библиотек и разнообразных фреймворков, таких как jQuery, для программирования на стороне клиента, предоставил всю мощь языка JavaScript для широкой аудитории. jQuery предоставляет свой собственный API, методы и синтаксические особенности. Порой которые похожи друг на друга, но отличающиеся в чем-то. Это заметка должна избавить вас от путаницы</p>

<!-- more -->


<h3>.parent(), .parents() .closest()</h3>

<p>Все три эти метода предоставляют доступ вверх над элементами по дереву DOM, но они тем временем все-таки отличаются</p>

<h4>parent(selector)</h4>

<p>Попросту находит одного непосредственного родителя для элемента или элементов. Он также может принимать селектор в виде параметра, который будет полезен для нахождения родителя в определенном контексте.</p>

<p><code>javascript
$('span.my').parent().css('border', '1px solid red');
$('p').parent('div.sidebar').css('border', '1px solid red');
</code></p>

<p>В первой строке мы получаем родителя с классом my. Во второй же получает родителей для всех элементов <p>, при условии, что родитель его <div> с классом .sidebar.</p>

<p>Возможность ограничить выборку метода как во второй строке в примере выше &ndash; стандартная &ldquo;плюшка&rdquo; jQuery. Большинство методов для DOM-манипуляций позволяют указать селектор.</p>

<h4>parents(selector)</h4>

<p>Работает по тому же принципу, что и .parent() за исключением того, что данный метод не ограничен одним уровнем и может возвращать несколько предков. К примеру:</p>

<p><code>html
$('li.naivgation').parents('li');
</code></p>

<p>Для каждого элемента <li> который содержит в себе класс <strong>navigation</strong>, возвращает всех родителей и предков, который в свою очередь тоже элементы списка <li>. Данный метод может быть полезен с многоуровнемым меню.</p>

<p>``` html</p>

<ul class="navigation">
  <li>Catalog
     <ul>
        <li>Electronics</li>
        <li>Animals</li>
        <li>Birds</li>
     </ul>
  </li>
  <li>About...
     <ul>
        <li>me</li>
        <li>company</li>
     </ul>
  </li>
</ul>


<p>```</p>

<p>Допустим нам нужно поменять цвет фона только для третьего уровня вложенности:</p>

<p>``` javascript
$(&lsquo;.navigation li&rsquo;).each(function() {
  if (2 == $(this).parents(&lsquo;.navigation li&rsquo;).length)</p>

<pre><code> $(this).css('background-color', 'cyan');
</code></pre>

<p>});
```</p>

<p>Для каждого элемента <li>, найденного в классе <strong>navigation</strong> находим количество <li>-предков. Если это два, значит раскрашиваем его.</p>

<h4>closest(selector)</h4>

<p>Это больше магия, но очень полезная. Данный метод работает также как и .parents(), исключая то, что возвращает только одного родителя или предка. Бывают ситуации, когда вам не нужны все родители, возвращаемые методом .parents(), тогда в дело вступает метод .closest(). Допустим, нам нужно узнать явлвется ли один элемент непосредственным наследником другого:</p>

<p><code>javascript
if (1 == $('.elem1').closest('.elem2').length)
  console.log('Непосредственный предок');
else
  console.log('Дальний родственник :)');
</code></p>

<p>Метод .closest() легко сэмулировать методом .parents(), ограничив количество возвращаемых элементов:</p>

<p><code>javascript
$($('.elem1').parents('.elem2').get(0)).css('border', '1px solid red');
</code></p>

<p>И еще метод .closest() начинает обход, начиная с элемента, удовлетворяющему селектору, а не с его родителя.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Zend Framework: WYSIWYG + FileBrowser]]></title>
    <link href="http://zudochkin.ru/2011/03/zend-framework-wysiwyg-filebrowser"/>
    <updated>2011-03-22T22:10:12+03:00</updated>
    <id>http://zudochkin.ru/2011/03/zend-framework-wysiwyg-filebrowser</id>
    <content type="html"><![CDATA[<p>Здравствуй, неизвестный читатель. На просторах интернета я не встретил толковой реализации, кроме одной, ссылку на которую я вставлю в конце поста.
После проделывания всех шагов, описанных в этом посте, у вас будет иметься возможность вставлять в форму визуальный редактор с файловым менеджером парой строк<!-- more -->:</p>

<p>``` php
&lt;?php</p>

<pre><code>$wysiwyg = new Vredniy_Form_Element_WysiwygElrte('content', array(
    'label' =&gt; 'Контент'
));
</code></pre>

<p>   $this->addElement($wysiwyg);
?>
```</p>

<p>Не правда ли удобно? Итак, начнем все подробно разбирать.</p>

<h5>Шаг номер 1.</h5>

<p>Качаем <a href="http://elrte.org/">elrte</a> и <a href="http://elrte.org/elfinder">elFinder</a> с официального сайта. Здесь ни у кого не должно возникнуть сложностей. Дальше, чтобы не путаться в путях предлагаю эти библиотеки разместить как у меня. <strong>/public/elrte</strong> и <strong>/public/elfinder</strong> соответственно.</p>

<h5>Шаг номер 2.</h5>

<p>Создаем кастомизированный элемент формы <strong>Vredniy_Form_Element_WysiwygElrte</strong> (над названием, скорей всего нужно будет подумать)</p>

<p>``` php
&lt;?php
class Vredniy_Form_Element_WysiwygElrte extends Zend_Form_Element_Xhtml
{</p>

<pre><code>public $helper = 'formWysiwygElrte';
</code></pre>

<p>}
?>
```</p>

<h5>Шаг номер 3.</h5>

<p>Этот элемент формы будет вести себя как стандартный зендовский. Теперь напишем свой вью хелпер, который и будет заниматься всей грязной работой: подключать все необходимые скрипты, стили и генерировать контент исходного элемента формы.</p>

<p>``` php
&lt;?php
class Vredniy_View_Helper_FormWysiwygElrte extends Zend_View_Helper_FormElement
{</p>

<pre><code>public function formWysiwygElrte($name = null, $value = null, $attribs = null)
{
    if (!$this-&gt;view-&gt;jQuery()-&gt;isEnabled())
            $this-&gt;view-&gt;jQuery()-&gt;enable();

    if (!$this-&gt;view-&gt;jQuery()-&gt;uiIsEnabled())
            $this-&gt;view-&gt;jQuery()-&gt;uiEnable();


    $elrte_base_uri = "/js/elrte/";

    $this-&gt;view-&gt;headLink()-&gt;appendStylesheet("{$elrte_base_uri}css/elrte.full.css");
    $this-&gt;view-&gt;headScript()-&gt;appendFile("{$elrte_base_uri}js/elrte.full.js");
    $this-&gt;view-&gt;headScript()-&gt;appendFile("{$elrte_base_uri}js/i18n/elrte.ru.js");


    $elfinder_base_uri = "/js/elfinder/";
    $this-&gt;view-&gt;headLink()-&gt;appendStylesheet("{$elfinder_base_uri}css/elfinder.css");
    $this-&gt;view-&gt;headScript()-&gt;appendFile("{$elfinder_base_uri}js/elfinder.full.js");
    $this-&gt;view-&gt;headScript()-&gt;captureStart() ?&gt;
        var opts = {
            lang : 'ru',
            styleWithCss : false,
            absoluteURLs: false, // чтобы отображался не полный путь, а относительный от корня
            width   : 800,
            height  : 200,
            toolbar : 'maxi', // все возможные панели инструментов, удалить легче :)
            fmAllow  : true,
            fmOpen   : function(callback) {
                $('&lt;div id="myelfinder" /&gt;').elfinder({
                    url : '&lt;?php echo $elfinder_base_uri; ?&gt;connectors/php/connector.php',
                    lang : 'ru',
                    dialog : {
                        width : 900, // ширина файлового менеджера
                        modal : true,
                        title : 'Выбираем файлик'
                    }, // открываем в диалоговом окне
                    closeOnEditorCallback : true, // закрываем после выбора файла
                    editorCallback : callback
                })
            }
        };

        $().ready(function() {
          // создаем редактор
            $('#&lt;?php echo $name; ?&gt;').elrte(opts);
        });
    &lt;?php $this-&gt;view-&gt;headScript()-&gt;captureEnd();

    $info = $this-&gt;_getInfo($name, $value, $attribs);
    extract($info); // name, value, attribs, options, listsep, disable

    // is it disabled?
    $disabled = '';
    if ($disable) {
        // disabled.
        $disabled = ' disabled="disabled"';
    }

    // build the element
    $xhtml = '&lt;textarea name="' . $this-&gt;view-&gt;escape($name) . '"'
            . ' id="' . $this-&gt;view-&gt;escape($id) . '"'
            . $disabled
            . $this-&gt;_htmlAttribs($attribs) . '&gt;'
            . $this-&gt;view-&gt;escape($value) . '&lt;/textarea&gt;';

    return $xhtml;

}
</code></pre>

<p>}</p>

<p>?>
```</p>

<p>В исходном коде я старался максимально комментировать не особо очевидные моменты, кроме подключения jQuery и jQueryUI (как их подключить расскажу в конце, чтобы не отвлекать вас от основной идеи).</p>

<h5>Шаг номер 4.</h5>

<p>Изменяем опции коннектора, который отвечает за файловый менеджер <strong>public/js/elfinder/php/connector.php</strong></p>

<p>``` php
&lt;?php
// из основного файла ZF index.php я вынес в отдельный
// константы, чтобы было удобно их подключать извне
require_once realpath(dirname(<strong>FILE</strong>) . &lsquo;/../../../../constants.php&rsquo;);
error_reporting(0); // Set E_ALL for debuging</p>

<p>if (function_exists(&lsquo;date_default_timezone_set&rsquo;)) {
   date_default_timezone_set(&lsquo;Europe/Moscow&rsquo;);
}</p>

<p>include_once dirname(<strong>FILE</strong>).DIRECTORY_SEPARATOR.&lsquo;elFinder.class.php&rsquo;;</p>

<p>/<strong>
 * Simple example how to use logger with elFinder
 </strong>/
class elFinderLogger implements elFinderILogger {</p>

<p>   public function log($cmd, $ok, $context, $err=&lsquo;&rsquo;, $errorData = array()) {</p>

<pre><code>  if (false != ($fp = fopen('./log.txt', 'a'))) {
     if ($ok) {
        $str = "cmd: $cmd; OK; context: ".str_replace("\n", '', var_export($context, true))."; \n";
     } else {
        $str = "cmd: $cmd; FAILED; context: ".str_replace("\n", '', var_export($context, true))."; error: $err; errorData: ".str_replace("\n", '', var_export($errorData, true))."\n";
     }
     fwrite($fp, $str);
     fclose($fp);
  }
</code></pre>

<p>   }</p>

<p>}</p>

<p>$opts = array(</p>

<pre><code>'root'            =&gt; APPLICATION_PUBLIC . '/upload/files', // path to root directory
'URL'             =&gt; '/upload/files/', // root directory URL
'rootAlias'       =&gt; 'Галерея', // display this instead of root directory name
</code></pre>

<p>);</p>

<p>$fm = new elFinder($opts);
$fm->run();
?>
```</p>

<p>Тут самое интересное это массив <strong>$opts</strong>, в котором мы задаем корневую папку нашего файлового хранилища и меняем название &ldquo;Home&rdquo; на более привычное русскому глазу &ldquo;Галерея&rdquo;.</p>

<h5>Шаг номер 5 (костыль).</h5>

<p>У меня не получилось &ldquo;из коробки&rdquo; заставить принимать правильный размер диалоговое окно, поэтому я заменил 6303 строчку в файле /js/elrte/js/elrte.full.js на свое</p>

<p><code>javascript
width    : 670,
// @todo: чтобы помещалась волшебная кнопочка
</code></p>

<h5>Шаг номер 6.</h5>

<p>Подключаем скрипты jQuery, jQuery и необходимые для них стили. Корневой файл <strong>Bootstrap.php</strong></p>

<p>``` php
&lt;?php</p>

<pre><code>protected function _initViewHelpers()
{
    $this-&gt;bootstrap('layout');
    $layout = $this-&gt;getResource('layout');
    $view = $layout-&gt;getView();
    $viewRenderer = Zend_Controller_Action_HelperBroker::getStaticHelper('viewRenderer');
    $viewRenderer-&gt;view-&gt;addHelperPath("Vredniy/View/Helper", 'Vredniy_View_Helper');

    // init 960gs-fluid
    $view-&gt;headLink()-&gt;appendStylesheet('/css/960gs-fluid/reset.css')
            -&gt;headLink()-&gt;appendStylesheet('/css/960gs-fluid/text.css')
            -&gt;headLink()-&gt;appendStylesheet('/css/960gs-fluid/grid.css')
            -&gt;headLink()-&gt;appendStylesheet('/css/960gs-fluid/layout.css')
            -&gt;headLink()-&gt;appendStylesheet('/css/960gs-fluid/ie/ie6.css', 'all', 'IE6')
            -&gt;headLink()-&gt;appendStylesheet('/css/960gs-fluid/ie/ie.css', 'all', 'IE')
    ;


    // init jQuery &amp; UI
    ZendX_JQuery::enableView($view);
    $view-&gt;jQuery()
            -&gt;setLocalPath('/js/jquery/jquery-1.4.4.min.js')
            -&gt;setUiLocalPath('/js/jqueryui/jquery-ui-1.8.10.custom.min.js')
            -&gt;addStylesheet('/css/jqueryui/themes/start/jquery-ui-1.8.10.custom.css')
    ;

    // set doctype
    $view-&gt;doctype('HTML5');

    // set title separator
    $view-&gt;headTitle()-&gt;setSeparator(' :: ');
}
</code></pre>

<p>?>
```</p>

<p>jQuery располагаем в папку <strong>/js/jquery/</strong>, jQueryUI &ndash; в <strong>/js/jquery/ui</strong> и темы в <strong>/css/jqueryui/themes/</strong></p>

<p>И последнее, разобьем наш файл /public/index.php на два: сам файл</p>

<p>``` php
&lt;?php
require_once &lsquo;constants.php&rsquo;;
// Ensure library/ is on include_path
set_include_path(implode(PATH_SEPARATOR, array(</p>

<pre><code>realpath(APPLICATION_PATH . '/../library'),
get_include_path(),
</code></pre>

<p>)));</p>

<p>/<em>* Zend_Application </em>/
require_once &lsquo;Zend/Application.php&rsquo;;</p>

<p>// Create application, bootstrap, and run
$application = new Zend_Application(</p>

<pre><code>APPLICATION_ENV,
APPLICATION_PATH . '/configs/application.ini'
</code></pre>

<p>);
$application->bootstrap()</p>

<pre><code>        -&gt;run();
</code></pre>

<p>?>
```</p>

<p>и <strong>constants.php</strong></p>

<p>``` php
&lt;?php</p>

<p>// Define path to application directory
defined(&lsquo;APPLICATION_PATH&rsquo;)</p>

<pre><code>    || define('APPLICATION_PATH', realpath(dirname(__FILE__) . '/../application'));
</code></pre>

<p>// Define application environment
defined(&lsquo;APPLICATION_ENV&rsquo;)</p>

<pre><code>    || define('APPLICATION_ENV', (getenv('APPLICATION_ENV') ? getenv('APPLICATION_ENV') : 'production'));
</code></pre>

<p>// public folder
defined(&lsquo;APPLICATION_PUBLIC&rsquo;)</p>

<pre><code>    || define('APPLICATION_PUBLIC', realpath(APPLICATION_PATH . '/../public'));
</code></pre>

<p>?>
```</p>

<p>Дальше используем. Создадим форму с 2мя элементами: нашим wysiwyg'ом и простую кнопку submit. Сказано-сделано.</p>

<p>``` php
&lt;?php</p>

<p>class Static_Form_Page extends Zend_Form
{</p>

<pre><code>public function init()
{
    $wysiwyg = new Vredniy_Form_Element_WysiwygElrte('content', array(
                'label' =&gt; 'Контент'
            ));
    // @todo add filters and validators

    $this-&gt;addElement($wysiwyg);
    $this-&gt;addElement('submit', 'submit', array(
        'label' =&gt; 'Change me'
            // @todo add filters and validators
    ));
}
</code></pre>

<p>}</p>

<p>?>
```</p>

<p>И в каком-нибудь контроллере напишем следующее:</p>

<p>``` php
&lt;?php</p>

<p>class Static_AdminController extends Zend_Controller_Action
{</p>

<pre><code>public function indexAction()
{
    $form = new Static_Form_Page();
    $form-&gt;getElement('submit')-&gt;setLabel('Создать');
    $this-&gt;view-&gt;form = $form;
    if ($this-&gt;getRequest()-&gt;isPost()) {
        if ($form-&gt;isValid($this-&gt;getRequest()-&gt;getPost())) {
            var_dump($form-&gt;getValues());
        }
    }
}
</code></pre>

<p>}
?>
```</p>

<p>В соответствующем скрипте вида напишем пару строк для вывода формы</p>

<p><code>php
Форма с Wysisyg и FileBrowser'ом
&lt;?php echo $this-&gt;form; ?&gt;
</code></p>

<p>Спасибо за потраченное на чтение сего поста время, надеюсь, информация вам оказалась полезной. Мне данной действо очень облегчило жизнь и я стал ближе на одну ступень к изобретению своего велосипеда &ndash; собственной CMS.</p>

<p><a href="/images/posts/2011-03-zend-framework-wysiwyg-filebrowser/elrte.jpg"><img class="image" src="/images/posts/2011-03-zend-framework-wysiwyg-filebrowser/elrte-300x164.jpg"></a></p>

<p>Ссылка на <a href="http://bit.ly/fDlu4C">пост</a>, которая собственно и подтолкнула меня на все работу. Автору того поста большое спасибо.</p>
]]></content>
  </entry>
  
</feed>
