<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: алгоритмы | Записки Вредного программиста]]></title>
  <link href="http://zudochkin.ru/blog/categories/alghoritmy/atom.xml" rel="self"/>
  <link href="http://zudochkin.ru/"/>
  <updated>2014-02-03T19:28:54+04:00</updated>
  <id>http://zudochkin.ru/</id>
  <author>
    <name><![CDATA[Зудочкин Дима]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Поиграем? или совместное использование ruby и php]]></title>
    <link href="http://zudochkin.ru/2012/03/lets-game-with-ruby-and-php"/>
    <updated>2012-03-17T18:14:35+04:00</updated>
    <id>http://zudochkin.ru/2012/03/lets-game-with-ruby-and-php</id>
    <content type="html"><![CDATA[<p>Сегодня заметка будет посвящена теме далекой от веб-программирования, она будет посвящена немного алгоритмам, немного парсингу и немного Mongodb. Будем сегодня играть в игру.<!-- more --></p>

<p>Часто по вечерам мы с женой играем в приложение на iPad'е под названием Словомания.</p>

<p><img class="image" src="/images/posts/2012-03-lets-game-with-ruby-and-php/slovomania.jpeg"></p>

<p>Смысл в нем, как вы, наверное, заметили из названия, поиск слов. На входе матрица 4х4, можно начать из любой клетки и задействовать соседние по одному разу, чтобы отыскать имеющееся у них в словаре слово (в том словаре есть и наречия, и глаголы, и прилагательные, и конечно же существительные).</p>

<p>Задача: отыскать все слова. Но я немного облегчу себе задачу, потому как по примерным подсчетам в матрице 4х4 всевозможных комбинаций поиска слова около 16 миллионов, что даже по скромным подсчетам и при словаре в ~160 тысяч слов займет около 5 часов. В данной заметке мы будем использовать матрицу 3х3, что сокращает количество комбинаций до 8 с небольшим тысяч, что вполне приемлимо, но недостаточно быстро, для одной игры, которая длится около минуты. Да и плевать, для меня главное решить задачу, хоть и читерить в игре не получится ).</p>

<p>Для начала отыщем все возможные комбинации, для этого воспользуемся php-скриптом <a href="/2011/02/depth-first-search-php/">поиска в ширину</a>, немного его изменив для наших нужд. На выходе должны получить файл, где в каждой строке одна комбинация.</p>

<p>Цифры на матрице я обозначил от 1 до 9 (3х3), поэтому в выходном файле будут строки подобного вида &ndash; 1,2,3,6,5,4,7,8,9.</p>

<p>Но сначала нам пригодится небольшой скрипт, который поможет построить граф для таблицы 3х3.</p>

<p>``` ruby
for i in (1..9) do
  print &ldquo;%-2s&rdquo; % i
  if i % 3 == 0 then print &ldquo;\n&rdquo; end
end</p>

<p>```</p>

<p>На выходе получим таблицу
```
1 2 3
4 5 6
7 8 9</p>

<p>```
которая поможет нам построить граф, ключами массива которого будут вершины &ldquo;откуда&rdquo;, значениями &ndash; точки &ldquo;куда&rdquo;, мы можем попасть из данной вершины. Из таблицы следует, что из точки 1, мы можем попасть в точки: 2,5 (по диагонали тоже можно) и 4. Так нам нужно описать каждую вершину графа.</p>

<p>``` php
array(&lsquo;2&rsquo;, &lsquo;4&rsquo;, &lsquo;5&rsquo;),
  &lsquo;2&rsquo; => array(&lsquo;1&rsquo;, &lsquo;3&rsquo;, &lsquo;5&rsquo;, &lsquo;4&rsquo;, &lsquo;6&rsquo;),
  &lsquo;3&rsquo; => array(&lsquo;2&rsquo;, &lsquo;5&rsquo;, &lsquo;6&rsquo;),
  &lsquo;4&rsquo; => array(&lsquo;1&rsquo;, &lsquo;2&rsquo;, &lsquo;7&rsquo;, &lsquo;8&rsquo;, &lsquo;5&rsquo;),
  &lsquo;5&rsquo; => array(&lsquo;1&rsquo;, &lsquo;2&rsquo;, &lsquo;3&rsquo;, &lsquo;4&rsquo;, &lsquo;6&rsquo;, &lsquo;7&rsquo;, &lsquo;8&rsquo;),
  &lsquo;6&rsquo; => array(&lsquo;3&rsquo;, &lsquo;2&rsquo;, &lsquo;5&rsquo;, &lsquo;9&rsquo;, &lsquo;8&rsquo;),
  &lsquo;7&rsquo; => array(&lsquo;4&rsquo;, &lsquo;5&rsquo;, &lsquo;8&rsquo;),
  &lsquo;8&rsquo; => array(&lsquo;4&rsquo;, &lsquo;6&rsquo;, &lsquo;6&rsquo;, &lsquo;7&rsquo;, &lsquo;9&rsquo;),
  &lsquo;9&rsquo; => array(&lsquo;5&rsquo;, &lsquo;6&rsquo;, &lsquo;8&rsquo;)
);</p>

<h1>циклы по всем вершинам графа,</h1>

<h1>каждая вершина может быть начальной и конечной</h1>

<p>for($i = 1; $i &lt;= 9; $i++)
  for($j = 1; $j &lt;= 9; $j++)</p>

<pre><code>find_path($graph, (string) $i, (string) $j);
</code></pre>

<h1>избавляемся от дубликатов</h1>

<p>$result = array_unique($paths);
echo &ldquo;\n\nКоличество комбинаций: &rdquo;, count($result), &ldquo;\n&rdquo;;</p>

<h1>записываем результаты в файл</h1>

<p>$fh = fopen(&lsquo;combinations.dat&rsquo;, &lsquo;a&rsquo;);
 fwrite($fh, implode(&ldquo;\n&rdquo;, $result));
fclose($fh);</p>

<p>```</p>

<p>В коде старался комментировать каждый момент, поэтому, думаю, должно быть понятно. На выходе у нас файлы <em>combinations.dat</em> с 8175 строками из всевозможных комбинаций.</p>

<p>Теперь давайте подготовим наш словарь. Я скачал какой-то орфографический словарь, каждая строка которого предствляла собой следующее <code>жопа#жопа %жопа, -ы</code></p>

<p>Я решил сохранить два первых слова, точнее слово и ударение (которое в данном проекте не используется). Первое слово отделено от второго #, второе от остального %. По мере парсинга словаря, мы будем записывать все слова в нашу mongo базу данных для быстрого поиска по ней в дальнейшем.</p>

<p>``` ruby</p>

<h1>coding: utf-8</h1>

<p>require &lsquo;mongo&rsquo;
require &lsquo;mongo_mapper&rsquo;</p>

<p>MongoMapper.database = &lsquo;words&rsquo;</p>

<p>class Word
  include MongoMapper::Document</p>

<p>  key :word
  key :word2
end</p>

<p>f = File.open(&lsquo;./dic.txt&rsquo;, &lsquo;r&rsquo;)</p>

<h1>цикл по всем строкам словаря</h1>

<p>f.lines.each do |line|
  word, word2 = line.split(&lsquo;#&rsquo;) # отделяем первое слово
  word2 = word2.split(&lsquo;%&rsquo;)[0] # и второе
  puts &ldquo;#{word} #{word2}\n&rdquo;</p>

<p>  # и сохраняем его
  Word.create(</p>

<pre><code>:word =&gt; word,
:word2 =&gt; word2
</code></pre>

<p>  )
end</p>

<p>```</p>

<p>Если вам лень запускать подобный скрипт, то в корне проекта лежит файл <em>words.json</em>, содержащий все слова, вы можете импортировать его в свою mongo базу командой <code>mongoimport -d DB -c COLLECTION words.json</code>.
Далее, чтобы ускорить и без того медленное приложение, нужно создать индекс в базе на поле word, запускаем mongo-терминал, выбираем базу данных <em>use DB</em> и пишем следующее
<code>db.COLLECTION.ensureIndex({word: 1})</code>, где DB &ndash; имя ваше базы данных, а COLLECTION &ndash; имя коллекции.</p>

<p>Итак, переходим к завершающей части &ndash; моменту истины, так сказать, поиску слов.</p>

<p>``` ruby</p>

<h1>encoding: utf-8</h1>

<p>require &lsquo;mongo&rsquo;
require &lsquo;mongo_mapper&rsquo;</p>

<p>MongoMapper.database = &lsquo;words&rsquo;</p>

<p>class Word
  include MongoMapper::Document</p>

<p>  key :word
  key :word2
end</p>

<h1>файл с полученным в предыдущих шагах комбинациями</h1>

<p>COMBINATIONS_FILE = &lsquo;./combinations.dat&rsquo;</p>

<h1>файл с результатами</h1>

<p>OUTPUT_FILE = &lsquo;./results.dat&rsquo;</p>

<h1>наше игровое поле</h1>

<p>alphabet = %w{
  к о ж
  а п у
  а р р
}</p>

<h1>поиск текущего слова в словаре</h1>

<p>def find_a_word(word)
  w = Word.where(:word => word).first
  if w</p>

<pre><code>return w.word
</code></pre>

<p>  else</p>

<pre><code>return nil
</code></pre>

<p>  end
end</p>

<h1>из комбинации, учитывая alphabet, составляем &ldquo;слово&rdquo;</h1>

<p>def number_to_letters(alphabet, line)
  letters = line.split(&lsquo;,&rsquo;)
  word = []
  letters.each do |letter|</p>

<pre><code>word &lt;&lt; alphabet[letter.to_i - 1]
</code></pre>

<p>  end
  word.join()
end</p>

<h1>основной цикл приложение</h1>

<h1>проходимся во всему списку комбинаций</h1>

<p>File.open(COMBINATIONS_FILE, &lsquo;r&rsquo;) do |f|
  f.lines.each do |line|</p>

<pre><code># составляем слово
n_t_l = number_to_letters(alphabet, line)
# находим в бд
result = find_a_word(n_t_l)
unless result.nil? then # если нашли
  puts n_t_l # выводим его
  File.open(OUTPUT_FILE, 'a') do |output|
    output.puts n_t_l # и записываем в файл
  end
end
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>После этого запускаем скрипт <code>ruby find-words.rb</code>, откидываемся на спинку стула и ждем результат. Начнут появляться на экране слова, которые были найдены этим скриптом, возможны повторения, потому что одно слово может быть составлено из разных комбинаций.</p>

<p>Удачи в кодинге и побольше интересных задач, которые вам под силу решить :).</p>

<p>P.S.: репозиторий, как всегда, доступен на <a href="https://github.com/vredniy/game-ruby-php">github</a>.</p>

<hr />

<p>update 25.03.2012
Все-таки намного интереснее заставить приложение работать как задумывалось, а именно, чтобы оно находило слова из матрицы 4х4. Для этого мною были предприняты следующие меры:</p>

<ul>
<li>удаление лишних слов из словаря</li>
<li>оптимизация самого алгоритма</li>
<li>сужение диапазона поиска</li>
</ul>


<h3>Удаление лишних слов из словаря</h3>

<p>Пробежался я по словарю и понял, что там много слово, содержащих дефисы, скобки, пробелы. Некоторые слова состояли из одной-двух букв. Я решил с ними попрощаться, благо mongo поддерживает регулярные выражения.</p>

<p>``` ruby
MongoMapper.database = &lsquo;words&rsquo;</p>

<p>class Word
  include MongoMapper::Document
  key :word
end</p>

<h1>s = Word.all(:word => /^.<em>[-А-Я].</em>$/).each do |word|</h1>

<h1>s = Word.all(:word => /^.<em>[ё].</em>$/).each do |word|</h1>

<h1>s = Word.all(:word => /^.<em>[().\s+].</em>$/).each do |word|</h1>

<p>s = Word.all(:word => /^.<em>[&ndash;,.:;].</em>$/).each do |word|
  word.destroy
end</p>

<p>```
Запускаем и удаляем ненужные слова, из 160 тысяч слов, останется 140 тысяч, неплохо :)</p>

<h3>Оптимизация самого алгоритма</h3>

<p>Самый быстрый код &ndash; это мало кода. Поэтому максимально постараемся избавиться от методов. Выбросив все лишнее получим следующее.
``` ruby</p>

<h1>encoding: utf-8</h1>

<p>require &lsquo;mongo&rsquo;
require &lsquo;mongo_mapper&rsquo;</p>

<p>MongoMapper.database = &lsquo;words&rsquo;</p>

<p>class Word
  include MongoMapper::Document</p>

<p>  key :word
end</p>

<p>COMBINATIONS_FILE = &lsquo;./game.dat&rsquo;</p>

<p>Alphabet = %w{
ё ж е т
у ч е р
к о ю т
р м п ь
}</p>

<p>start = _start = Time.now
counter = 0</p>

<p>combinations = []</p>

<p>File.open(COMBINATIONS_FILE, &lsquo;r&rsquo;) do |f|</p>

<pre><code>while (line = f.gets)
  counter += 1
  line = line.split(',')
  if (3..9).include? line.size
      w = Word.first(:word =&gt; line.map{ |l| Alphabet[l.to_i - 1] }.join )
      line = nil
      combinations &lt;&lt; w.word unless w.nil?
  end

  if counter % 100_000 == 0
      p combinations.join ' ' unless combinations.empty?
      combinations = []
    p "#{Time.now - start} - #{counter}"
    start = Time.now
  end
end
</code></pre>

<p>end</p>

<p>p (Time.now &ndash; _start)</p>

<p>```</p>

<p>Код получился намного &ldquo;легче&rdquo; и быстрее.</p>

<h3>Сужаем диапазон поиска</h3>

<p>Чтобы хоть как-то еще прибавить скорость, я сузил длину слова, теперь проверяются только строки от 3 до 9 символов, это тоже очень хорошо сужает конечную выборку.</p>

<h3>Обратная связь приветствуется</h3>

<p>Если вы видите, что есть какие-то неточности или гипотезы по поводу оптимизации быстродействия кода, то всегда пожалуйста, я открыт для обсуждения всегда.</p>

<p>Не хочу быть излишне самоуверенным, но мне, кажется, что сейчас весь алгоритм упирается в &ldquo;железо&rdquo;, точнее скорость считывания с диска. (К сожалению, у меня нет ssd диска, чтобы это проверить).</p>

<p>В заключение картинка с какой скоростью отрабатывает скрипт. Первое число на картинке &ndash; количество секунд на 100_000 строк, считанных из файла и проверенных с каждой строкой словаря, содержащего ~ 140.000 слов. Второе число &ndash; сколько строк уже просмотрено. Всего комбинаций получилось, если рассматривать поле 4х4 &ndash; 12.000.000 штук. :)</p>

<p><img class="image" src="/images/posts/2012-03-lets-game-with-ruby-and-php/optimization.jpeg"></p>

<hr />

<h3>Обновление от 27.03.2012 (redis)</h3>

<p>Пришла еще одна мысля по оптимизации данного приложения, вместо mongodb, я решил попробовать использовать redis &ndash; очень быстрое ключ-значение хранилище.</p>

<p>Сначала нужно экспортировать базу mongo в redis, тут ничего сложного (с учетом того, что у вас и сам redis установлен, и redis gem).
``` ruby
require &lsquo;mongo&rsquo;
require &lsquo;mongo_mapper&rsquo;
require &lsquo;redis&rsquo;</p>

<p>MongoMapper.database = &lsquo;words&rsquo;</p>

<p>class Word</p>

<pre><code>include MongoMapper::Document

key :word
</code></pre>

<p>end</p>

<p>redis = Redis.new(:host => &ldquo;127.0.0.1&rdquo;, :port => 6379)
Word.all.each do |w|
  w = w.word
  unless /[-А-Я()]/.match w</p>

<pre><code>redis.set("word:#{w}", w)
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>Пробегаемся по всем словам из коллекции mongodb и сохраняем все слова в redis под ключом word:СЛОВО, чтобы не перепутать с другими ключами.</p>

<p>Теперь основной файл, только в качестве хранилища мы будем использовать redis.
``` ruby</p>

<h1>encoding: utf-8</h1>

<p>require &lsquo;redis&rsquo;
redis = Redis.new(:host => &ldquo;127.0.0.1&rdquo;, :port => 6379)</p>

<p>COMBINATIONS_FILE = &lsquo;./game.dat&rsquo;</p>

<p>Alphabet = %w{
ё ж е т
у ч е р
к о ю т
р м п ь
}</p>

<p>for i in (1..16) do</p>

<pre><code>print "%-3s" % Alphabet[i-1]
if i % 4 == 0 then print "\n" end
</code></pre>

<p>end</p>

<p>start = Time.now
_start = Time.now
counter = 0</p>

<p>combinations = []
lines = []</p>

<p>File.open(COMBINATIONS_FILE, &lsquo;r&rsquo;) do |f|
  f.each do |line|</p>

<pre><code>counter += 1
line = line.split(',')
if (3..9).include? line.size
  w = redis.get("word:" + line.map{ |l| Alphabet[l.to_i - 1] }.join)
  line = nil
  combinations &lt;&lt; w unless w.nil?
end

if counter % 100_000 == 0
  p combinations.uniq.join ' ' unless combinations.empty?
  combinations = []
  p "#{Time.now - start} - #{counter}"
  start = Time.now
end
</code></pre>

<p>  end
end</p>

<p>p (Time.now &ndash; _start)
p counter</p>

<p>```</p>

<p>Вывод: приложение стало заметно быстрее (в 3-5 раз), скриншот прилагаю.
<img class="image" src="/images/posts/2012-03-lets-game-with-ruby-and-php/redis-game.png"></p>

<p>Надеюсь, смогу добиться скорость выполнения в раза больше, чем сейчас. Мне нужно чтобы приложение проходило по всем комбинациям, сравнивая со всем словами в словаре и тратило при этом меньше минуты, сейчас около 3х.</p>
]]></content>
  </entry>
  
</feed>
