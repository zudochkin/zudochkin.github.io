<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: программирование | Записки Вредного программиста]]></title>
  <link href="http://zudochkin.ru/blog/categories/proghrammirovaniie/atom.xml" rel="self"/>
  <link href="http://zudochkin.ru/"/>
  <updated>2014-02-01T23:27:47+04:00</updated>
  <id>http://zudochkin.ru/</id>
  <author>
    <name><![CDATA[Зудочкин Дима]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Devconf 2013 - мои впечатления, ссылки на доклады и несколько фоток :)]]></title>
    <link href="http://zudochkin.ru/2013/06/devconf"/>
    <updated>2013-06-18T21:31:24+04:00</updated>
    <id>http://zudochkin.ru/2013/06/devconf</id>
    <content type="html"><![CDATA[<p>Прошло 4 года с моего последнего и в то же время первого визита на конференцию разработчиков. 4 года назад сидел я в секции #php и почти не понимал что происходит, не понимал о каких проблемах говорят докладчики, но для меня это было, однозначно, в новинку и очень интересным. В течение всех этих лет желание посещать технические конференции только росло, но возможности, к сожалению, предоставлялось из-за не очень заинтересованных в этом работодателей. <!--more--></p>

<p><img class="image" src="/images/posts/2013-06-devconf/devconf2010.gif"></p>

<p>Чуть больше года назад я сменил язык разработки и окончательно перешел на Ruby. Теперь желание заключалось в том, чтобы посетить Ruby секцию на той же <a href="http://devconf.ru/">DevConf</a>. И вот, наконец, минимечта сбылась, и я на конференции.</p>

<p>К сожалению, пришлось немного опоздать из-за того, что любовь ко сну немного пересилила любовь к получению новых знаний.</p>

<h3>Доклады</h3>

<p><img class="image" src="/images/posts/2013-06-devconf/2013-06-14_11.16.27.jpg"></p>

<p>И вот регистрация и начало нового доклада, который не хотелось пропускать, ведь выступал чел, забаненный на Github'е, специалист по безопасности <a href="https://twitter.com/homakov" title="@homakov">Егор Хомяков</a> со своим докладом &ldquo;Безопасный сайт на примере Rails&rdquo;. Его рассказал про всевозможные атаки в web'е, как с ними бороться нужно и как эти проблемы решают (или как не решают) нами любимые рельсы. Узнал много нового о типах атаках и способов защиты с ними. <a href="http://f.cl.ly/items/2G3g462j2T0o1w0g3K2o/rails%20and%20security.pdf" title="Безопасный сайт на примере Rails">Презентацию</a> помог достать из интернетов товарищ <a href="https://twitter.com/milushov">roma</a>, за что ему отдельное спасибо.</p>

<p><img class="image" src="/images/posts/2013-06-devconf/2013-06-14_11.04.56.jpg"></p>

<p>Дальше был кофебрейк, на котором было сложно протиснуться, поэтому кофе попить не удалось, ну, хоть, водички попили.</p>

<p>После кофебрейка удалось таки занять сидячие места и спокойно с интересом послушать очередного докладчика, которым оказался разработчик из Питера Николай Рыжиков, рассказавший нам о <a href="http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Проблемно-ориантированное проектирование">DDD</a> в <a href="http://f.cl.ly/items/2b3C0H3S0n2a473x1M3Z/DDD%20on%20rails.pdf">докладе</a> под названием <strong>&ldquo;Domain Driven Design on Rails&rdquo;</strong>. Я очень часто слышал эту аббревиатуру, но так до конца и не понимал что это, как это готовить и как использовать в своих проектах (и сейчас не понимаю, но я научусь).</p>

<p>После очередного интересного доклада, после которого захотелось освоить эти забавные, но еще так непонятные 3D, мы послушали <a href="http://www.slideshare.net/profyclub_ru/13-20022107">доклад</a> с громким названием <strong>&ldquo;Быстрое тестирование Ruby on Rails&rdquo;</strong> от Александра Балашова, из компании-спонсора DevConf Evrone. Рассказ получился очень поверхностным, который можно уложить в одно приложение: <em>&ldquo;Используйте поменьше обращений к БД и юзайте <a href="https://github.com/jonleighton/spring">Spring</a>, <a href="https://github.com/burke/zeus">Zeus</a> или <a href="https://github.com/sporkrb/spork">spork</a> для ускорения запуска приложения&rdquo;</em>.</p>

<p><img class="image" src="/images/posts/2013-06-devconf/2013-06-14_13.57.20.jpg"></p>

<p>Следующий доклад <strong>&ldquo;Проектирование API&rdquo;</strong> прочитал <a href="https://twitter.com/igkuz" title="@igkuz">Игорь Кузнецов</a> &ndash; Ruby разработчик из Undev.ru. Этот доклад я очень хотел послушать, потому что реализовывать API самому не приходилось,  а очень хотелось попробовать написать что-то подобное, наступая на &ldquo;подводные камни&rdquo;. Но, к сожалению, вопросов, которые я бы хотел услышать в докладе не освещалось, а именно аутентификация и больше практических советов, аля как использовать rails-api в связке с гемом devise, какие есть костыли и прочее. Но автор коснулся лишь теоретических основ проектирования API, что тоже было очень интересно послушать, кое-что я занес в заметки, чтобы в дальнейшем посмотреть. Интересно было рассказано про версионирование: отличие мажорной и минорной версии, какие изменения должно увеличивать мажорную, а какие минорную версию. И, конечно же стоит отметить упоминания автором доклада темы <a href="http://json-schema.org/">JSON Schema</a>, которая одновременно является и документацией для API, и валидатором.</p>

<p><img class="image" src="/images/posts/2013-06-devconf/2013-06-14_14.40.35.jpg"></p>

<p>После доклада, который закончился немного раньше мы двинули на обед, благо, что нас отпустили немного раньше положенного времени, ибо, когда мы уходили с обеда очередь за едой была километровая. Покормили знатно, как в Египте прям, шведский стол, куча блюд и куча сладостей с фондю. В общем обед придал новых сил и мы двинули на очередной доклад.</p>

<p>Александров Игорь из компании JetRockets рассказал нам о <a href="https://speakerdeck.com/alexandrov/billing-in-rails-saas-applications">&ldquo;Биллинге в SaaS-системах на Rails&rdquo;</a>. Перед каждым, кто принимает платежи в своих проектах обязательно встает вопрос отдавать биллинг на аутсорс или реализовывать свою систему оплаты. Игорь рассказал и про плюсы, и про минусы обеих систем. Дальше рассказал про путь, в котором вы разрабатывает свою систему: биллинговый интервал и страшное название <strong>PCI-compliant</strong>, являющееся набором требований для организаций, сервисов, которые работают с платежными данными пользователей. Специально для Devconf 2013 было разработано приложение <a href="https://github.com/igor-alexandrov/spaceship" title="Demo application for DevConf 2013">SpaceShip</a>, показывающее все, что сказал автор доклада: биллинговые периоды, тарифы и пр.</p>

<p><img class="image" src="/images/posts/2013-06-devconf/2013-06-14_16.48.29.jpg"></p>

<p>Ну а дальше был апофеоз всего Devconf'а, доклад, ради которого стоило пойти на конференцию, даже если бы не было вкусного обеда  и остальных докладчиков. <a href="http://kaize.ru/" title="ортодоксальный приверженец SOLID-принципа">Кирилл Мокевнин</a>, известный и php мире, и в мире Ruby on Rails, превосходный докладчик и специалист, разбирающийся в своем деле. Доклад назывался <a href="https://speakerdeck.com/mokevnin/arkhitiekturnyie-praktiki-v-rails">&ldquo;Архитектурные практики в Rails&rdquo;</a>, где Кирилл поделился со слушателями своим опытом разработки, рассказал о проблемах, с которыми сталкивался и как их решал сам.
Были описаны следующие проблемы:</p>

<ul>
<li>Организация иерархии в  папках с контроллерами и моделями, <a href="http://habrahabr.ru/post/136461/" title="Ссылка автора на свой пост на Хабрахабре">наименования модулей</a> и написание удобных правил в <code>config/routes.rb</code>.</li>
<li>Ссылки в js, замечатели ли вы что очень часто пишем в javascript-coffescript файлах, нечто похожее на &ldquo;/posts/#{post.slug}&rdquo;, Кирилл рекомендует использовать для этих целей гем <a href="https://github.com/railsware/js-routes/" title="Bringing Rails named routes to javascript">js-routes</a>.</li>
<li>Использовать для фильрации и сортировки гем <a href="https://github.com/ernie/ransack" title="Object-based searching. The successor to MetaSearch">ransack</a>. Данный гем не пробовал, поэтому ничего пока сказать не могу.</li>
<li>Также автор затронул вопрос DDD, чем однозначно убедил прочитать в ближайшее время книгу Эрика Эванса &ldquo;Domain-Driven Design. Tackling Complexity in the Heart of Software&rdquo;</li>
<li>Также несколько примеров, которые приводит Кирилл

<ul>
<li><a href="http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/" title="7 Patterns to Refactor Fat ActiveRecord Models">7 Patterns to Refactor Fat ActiveRecord Models</a></li>
<li><a href="https://github.com/kaize/nastachku">Проект nastachku.ru на Github'е</a></li>
<li>не стесняйтесь использовать custom inputs в simple_form</li>
<li>используйте gem версии популярных js библиотек, иначе вы забываете их обновлять :) <a href="https://github.com/grosser/vendorer" title="Vendorer keeps your dependencies documented, cached and up to date">Gem Vendorer, если нет гема для библиотеки, которую вы используете</a></li>
<li>before фильтры, а также before_validate &ndash; зло</li>
</ul>
</li>
</ul>


<p>К сожалению, после этого доклада пришлось покинуть конференцию, сожалея только о том, что пропущу очередной доклад Кирилла Мокевнина &ldquo;Ментальное программирование&rdquo;, но его по техническим причинам прервали. Сам Кирилл, предлагает посмотреть <a href="http://www.youtube.com/watch?v=eEEHWQNuCLQ" title="Ментальное программирование">видео</a> на Youtube'e с его предыдущим выступлением, которое называется также.</p>

<h3>Подводя итоги</h3>

<p>… хочется сказать, что конференция была очень поучительна, но почему-то я ожидал от нее большего. Многие вопросы, которые освещались были мне знакомы, поэтому я прослушал их как чужое мнение на вопросы, с которыми приходилось иметь дело.
Но, вцелом, хочется поблагодарить спонсоров и огранизаторов конференции за такую замечательную конференцию, которая дает &ldquo;волшебный пендель&rdquo;, прививает очередную порцию любви к программированию и дает пообщаться с коллегами по цеху о методах решения тех или иных вопросов :)</p>

<h3>P.S.</h3>

<p>Несколько дней писал данный пост, вносил кучу дополнений и изменений, но, думаю, что на этом достаточно, иначе пост никогда не увидит свет.</p>

<h3>P.S. №2</h3>

<p>Презентации с доклада, которые пропустил:</p>

<ul>
<li>от <a href="https://twitter.com/makaroni4" title="@makaroni4">Анаталия Макаревича</a> <a href="http://www.slideshare.net/profyclub_ru/12-20022066">&ldquo;Рефакторинг Ruby кода&rdquo;</a></li>
<li>от <a href="https://twitter.com/killthekitten" title="@killthekitten">Николая Шебанова</a> <a href="http://www.slideshare.net/profyclub_ru/14-20022236">&ldquo;Спасение утопающих &ndash; покрываем тестами взрослый Ruby on Rails проект&rdquo;</a></li>
</ul>


<h3>P.S. №3</h3>

<p>Зарабатываю кружечку от Reg.ru, поднимая тяжести. <img class="image" src="/images/posts/2013-06-devconf/13.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Парсим news.ycombinator.com или не рельсами едиными жив человек (Sinatra, DataMapper)]]></title>
    <link href="http://zudochkin.ru/2013/03/sinatra-datamapper-news-combinator"/>
    <updated>2013-03-05T23:29:26+04:00</updated>
    <id>http://zudochkin.ru/2013/03/sinatra-datamapper-news-combinator</id>
    <content type="html"><![CDATA[<p>Дело было вечером, делать было нечего и решил я написать небольшое приложение на Sinatra с Datamapper'ом. За идеей далеко ходить также не пришлось: решил написать небольшой &ldquo;фильтратор&rdquo; интересного для меня контента из новостей news.ycombinator.ru.<!-- more --> Не стал изобретать велосипед на этот раз и интересными буду считать новости, названия которых содержат определенные слова. Будем отображать список прочитанных и непрочитанных новостей. Список новостей каждый час будет обновляться по cron'у &ndash; вот и вся задача.</p>

<p>Начнем с реализации: для этого нам понадобится:</p>

<ul>
<li>data_mapper с двумя адаптерами (sqlite3 для локального использование и postgresql для production'а)</li>
<li>sinatra</li>
<li>coffeeScript, хоть можно было и легко обойтись без него</li>
<li>slim в качестве шаблонизатора</li>
</ul>


<p>Итак, поехали:</p>

<p>Gemfile:</p>

<p><div>
  <pre><code class='ruby'>source &amp;lsquo;https://rubygems.org&amp;rsquo;&lt;/p&gt;

&lt;p&gt;gem &amp;lsquo;sinatra&amp;rsquo;
gem &amp;lsquo;data_mapper&amp;rsquo;&lt;/p&gt;

&lt;p&gt;group :development do
  gem &amp;lsquo;dm-sqlite-adapter&amp;rsquo;
  gem &amp;lsquo;capistrano&amp;rsquo;
end&lt;/p&gt;

&lt;p&gt;group :production do
  gem &amp;lsquo;dm-postgres-adapter&amp;rsquo;
end&lt;/p&gt;

&lt;p&gt;gem &amp;lsquo;slim&amp;rsquo;
gem &amp;lsquo;coffee-script&amp;rsquo;
gem &amp;lsquo;whenever&amp;rsquo;, :require =&gt; false&lt;/p&gt;

&lt;p&gt;gem &amp;lsquo;nokogiri&amp;rsquo;&lt;/p&gt;

&lt;p&gt;gem &amp;lsquo;unicorn&amp;rsquo;</code></pre>
</div>
</p>

<p>В нем нет ничего необычного, добавляем необходимые гемы для разных сред.</p>

<p>Теперь самое интересное: основной файл приложения, который занимает больше всего места.</p>

<p>./app.rb</p>

<p>``` ruby</p>

<p>require &lsquo;sinatra&rsquo;
require &lsquo;slim&rsquo;</p>

<p>require &lsquo;coffee-script&rsquo;
require &lsquo;data_mapper&rsquo;</p>

<p>DataMapper::Property::String.length(400)</p>

<p>configure :development do
  DataMapper.setup(:default, &lsquo;sqlite3:./db/articles.db&rsquo;)
end</p>

<p>configure :production do
  DataMapper.setup(:default, &lsquo;postgres://deployer:funnydb@localhost/ycombinator&rsquo;)
end</p>

<p>class Article
  include DataMapper::Resource</p>

<p>  INTERESTING_KEYWORDS = %w(ruby rails coffee js javascript ember angular</p>

<pre><code>backbone tdd rspec shoulda gem unicorn nginx sinatra vim mac)
</code></pre>

<p>  property :id, Serial
  property :url, String, :unique_index => :u, :required => true, :format => :url
  property :title, String, :required => true, :index => true
  property :interesting, Boolean, :default => false
  property :read_at, DateTime
  timestamps :created_at, :updated_on</p>

<p>  def interesting?</p>

<pre><code>!!(title =~ Regexp.new(INTERESTING_KEYWORDS.join('|'), Regexp::IGNORECASE))
</code></pre>

<p>  end</p>

<p>  def self.interesting_to_me</p>

<pre><code>all(:interesting =&gt; true)
</code></pre>

<p>  end</p>

<p>  def self.unread</p>

<pre><code>all(:read_at =&gt; nil)
</code></pre>

<p>  end</p>

<p>  def self.read</p>

<pre><code>all(:read_at.not =&gt; nil)
</code></pre>

<p>  end</p>

<p>  def self.search(term=&lsquo;&rsquo;)</p>

<pre><code>if DataMapper.repository.adapter.options[:scheme] == 'sqlite3'
  all(:title.like =&gt; "%#{term.to_s}%")
else
  all(:conditions =&gt; [ 'title ILIKE ?', "%#{term.to_s}%" ])
end
</code></pre>

<p>  end
end</p>

<p>DataMapper.finalize</p>

<h1>DataMapper.auto_migrate!</h1>

<p>DataMapper.auto_upgrade!</p>

<p>helpers do
  def do_process(scope=nil)</p>

<pre><code>@search_term = params[:term].nil? ? nil : params[:term]
@articles = case scope
            when :all
              Article
            when :all_read
              Article.read
            when :all_unread
              Article.unread
            else
              Article.interesting_to_me.unread
            end.search(@search_term)
slim :index
</code></pre>

<p>  end
end</p>

<p>get &lsquo;/application.js&rsquo; do
  coffee :application
end</p>

<p>post &lsquo;/:id/read&rsquo; do
  @article = Article.get(params[:id])
  @article.read_at = Time.now
  @article.save
end</p>

<p>get &lsquo;/all&rsquo; do
  do_process :all
end</p>

<p>get &lsquo;/all/read&rsquo; do
  do_process :all_read
end</p>

<p>get &lsquo;/all/unread&rsquo; do
  do_process :all_unread
end</p>

<p>get &lsquo;/*&rsquo; do
  do_process
end</p>

<p>```</p>

<p>А теперь немного комментариев:</p>

<ul>
<li><p><strong>1-5 строки</strong> &ndash; подключаем необходимые для работы файлы</p></li>
<li><p><strong>7 строка</strong> &ndash; сообщаем DataMapper'y, что длина строки (String) не 80 символов, а 400, 255 не хватает.</p></li>
<li><p><strong>9-15</strong> &ndash; конфигурируем два адаптера: один для разработки, другой для продакшна.</p></li>
<li><p><strong>17-53</strong></p>

<ul>
<li><p><strong>20,21</strong> &ndash; объявляем интересные мне ключевые слова</p></li>
<li><p><strong>23-28</strong> &ndash; описываем все поля, которые будут в нашей модели</p></li>
<li><p><strong>30-32</strong> &ndash; метод interesting? определяет по заголовку новости интересна она мне или нет</p></li>
<li><p><strong>34-40</strong> &ndash; несколько используемых в приложении scope'ов</p></li>
<li><p><strong>46-52</strong> &ndash; метод search (из-за того, что в Postgresql like учитывает регистр букв, пришлось переписать оператор поиска на ilike, который этого не делает)</p></li>
</ul>
</li>
<li><p><strong>60-73</strong> &ndash; объявляем метод, который является &ldquo;сердцем&rdquo; и в зависимости от параметра заполняет коллекцию определенными статьями и рендерит вьюху ./views/index.slim</p></li>
<li><p><strong>76-78</strong> &ndash; рендерим coffeeScript, которые делает следующее, если мы кликам по новости, то отправляем ajax post запрос и помечаем новость как прочитанную (read_at = Time.now)</p></li>
<li><p><strong>80-84</strong> &ndash; сам метод, который помечает новость прочитанной при post запросе</p></li>
<li><p><strong>86-100</strong> &ndash; разные коллекции (все, прочитанные, непрочитанные и т.д.)</p></li>
</ul>


<p>теперь Rakefile, который будет парсить news.ycombinator.com каждый час</p>

<p>``` ruby</p>

<p>require &lsquo;./app&rsquo;</p>

<p>require &lsquo;nokogiri&rsquo;
require &lsquo;open-uri&rsquo;</p>

<p>desc &lsquo;Parse all articles&rsquo;
task :parse do
  doc = Nokogiri::HTML(open(&lsquo;http://news.ycombinator.com/&rsquo;))
  links = doc.css(&lsquo;td.title a&rsquo;)
  next_page_link = links.pop</p>

<p>  links.each do |link|</p>

<pre><code>href = link[:href]
text = link.children.text

unless Article.first(:url =&gt; href)
  Article.create(:url =&gt; href, :title =&gt; text)
end
</code></pre>

<p>  end</p>

<p>  puts Time.now.to_s
end</p>

<p>desc &lsquo;Update Interesting tasks&rsquo;
task :update_interesting do
  Article.all.each do |a|</p>

<pre><code>a.update(:interesting =&gt; a.interesting?)
puts "#{a.id} updated"
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>В нем всего две задачи: первая &ndash; парсит новости, вторая нужна для того, что если вдруг изменися интересные ключевые слова, то вы сможете легко обновить список инетересных вам новостей.</p>

<p>Файл, который отвечает за частоту выполнения определенных тасков ./config/shedule.rb
``` ruby</p>

<p>set :output, &lsquo;/home/deployer/projects/ycombinator/shared/log/shedule.log&rsquo;</p>

<p>job_type :rake, &ldquo;cd :path &amp;&amp; RACK_ENV=:environment bundle exec rake :task &mdash;silent :output&rdquo;</p>

<p>every :hour do
  rake &lsquo;parse&rsquo;
end</p>

<p>```</p>

<p>В первой строчке я указываю путь до файла с логами, чтобы каждый раз при запуске rake task'а в конец добавлялось время последнего обновления. В блоке с every можно очень гибко указать как часто выполняться, смотрите документацию к гему whenever.</p>

<p>Также я добавил несколько строк к файлу, выполняющего деплой из <a href="/unicorn-rbenv-nginx-postgresql/">Разворачиваем Rails приложение вместе с Capistrano</a>. ./config/deploy.rb</p>

<p>``` ruby</p>

<p>&hellip;
set :application, &lsquo;ycombinator&rsquo;
set :whenever_command, &ldquo;bundle exec whenever&rdquo;
require &ldquo;whenever/capistrano&rdquo;
&hellip;</p>

<p>```</p>

<p>Теперь мы можем запустить обновления cron'а deployer'а командой <code>cap whenever:update_crontab</code></p>

<p>После ее запуска вы можете проверить, что вышло, обновился ли cron, запустив на сервере, список cron задач: <code>crontab -l</code></p>

<p>Без комментариев оставлю вьюхи, но текст их приведу.</p>

<p>./views/application.coffee
``` coffeescript</p>

<p>$ &ndash;>
  $(&ldquo;.article&rdquo;).click &ndash;></p>

<pre><code>$.post "/" + $(this).attr("id") + "/read", -&gt;
$(this).parent('li').remove()
</code></pre>

<p>```</p>

<p>./views/layout.slim
``` ruby</p>

<p>doctype html</p>

<p>head
  title Ycombinator
  script src=&ldquo;http://zudochkin.ru//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js&rdquo;
  script src=&ldquo;http://zudochkin.ru/application.js&rdquo;</p>

<p>body
  a{ href=&ldquo;http://zudochkin.ru/all&rdquo; } All
  br
  a{ href=&ldquo;http://zudochkin.ru/all/read&rdquo; } All read
  br
  a{ href=&ldquo;http://zudochkin.ru/all/unread&rdquo; } All unread
  br
  a{ href=&ldquo;http://zudochkin.ru/&rdquo; } Home
  hr
  == yield</p>

<p>```</p>

<p>И наконец, ./views/index.slim
``` ruby</p>

<p>h1
  &lsquo; Unread articles
  &ndash; if @search_term</p>

<pre><code>= "searched by: '#{ @search_term }'"
</code></pre>

<p>p Search form
form{ method=&ldquo;get&rdquo; action=&ldquo;&rdquo; }
  input{ type=&ldquo;text&rdquo; name=&ldquo;term&rdquo; value=&ldquo;#{ @search_term }&rdquo; }
  input{ type=&ldquo;submit&rdquo; value=&ldquo;Find&rdquo; }</p>

<ul>
<li>if @search_term
a{ href=&ldquo;http://zudochkin.ru/&rdquo; } Home</li>
</ul>


<p>ul
  &ndash; @articles.each do |article|</p>

<pre><code>li
  a{ href="#{ article.url }" id="#{ article.id }" class="article" target="_blank" }
    = article.title
</code></pre>

<p>```</p>

<p>Получислось такое незамысловатое и некрасивое приложение :).</p>

<p><img class="image" src="/images/posts/2013-03-sinatra-datamapper-news-combinator/Screen-Shot-2013-03-05-at-10.33.43-PM.png"></p>

<p>Вместо заключения: чтобы мозги не были напичканы только рельсами (читать как одним фреймворком), мне кажется, необходимо покидать зону комфорта и писать небольшые приложения для души на смежных технологиях. Скажу честно, для того, чтобы реализовать это несложное приложение у меня ушло масса времени на чтение мануалов к Sinatra, DataMapper'у, нежели на написание кода. Но мне понравилось, практической ценности, конечно, приложение почти не имеет, но мозги размялись однозначно. Разминай мозги, коллега :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Перенос sqlite3 базы данных в Postgres (Heroku)]]></title>
    <link href="http://zudochkin.ru/2013/01/slite3-to-posgres-migration"/>
    <updated>2013-01-25T12:12:16+04:00</updated>
    <id>http://zudochkin.ru/2013/01/slite3-to-posgres-migration</id>
    <content type="html"><![CDATA[<p>Иногда бывает крайне необходимо конвертировать имеющуюся базу данных в одном формате в формат другой. Сегодня я расскажу вам как это быстро и безболезненно (почти) сделать.<!-- more --></p>

<p>Для начала нам понадобится замечательный <a href="https://github.com/ricardochimal/taps">gem taps</a> и запущенный с его помощью локальный сервер с бекендом из Sinatra.</p>

<p>Т.к. часто создавая новый проект, не хочется особо заморачиваться и создавать для этого отдельную базу данных в Postgres, я обычно использую базу данных по умолчанинию, в рельсах это, как вам известно, sqlite. Но бывает иногда необходимо скопировать данные с локальной базы данных в удаленную, к примеру, если вы хостите проект на heroku, где по умолчанию используется postgres.</p>

<p>Итак, поехали, для начала создаем сервер:</p>

<p><code>taps server sqlite://db/development.sqlite3 user pass</code>, где user &ndash; это имя пользователя для доступа к нашему серверу (серверу taps), pass соответственно пароль.</p>

<p>Дальше нам нужно скопировать нашу sqlite базу данных в postgres, для этого достаточно запустить одну команду:</p>

<p><code>taps pull postgres://zudochkin@localhost/project_development http://user:pass@localhost:5000</code>, где postgres &ndash; это адаптер базы данных, вы можете смело использовать mysql, zudochkin &ndash; имя пользователя для postgres, project_development &ndash; имя базы данных, куда я собираюсь импортировать данные, http://user:pass@localhost:5000 &ndash; коннектимся к нашему серверу, где в качестве имени пользователя указали user, в качестве пароля pass, а крутится все это дело по умолчанию на 5000 порте.</p>

<p>Теперь, если зайти и посмотреть через pgAdmin в нашу postgres базу данных, то мы увидим данные, скопированные из sqlite3.</p>

<p>Дальше необходимо сделать postgres дамп, для того, чтобы импортировать его в heroku базу данных.</p>

<p><code>pg_dump -Fc --no-acl --no-owner -h localhost -U zudochkin project_development &gt; project_development.dump</code></p>

<p>Загружаем дамп куда-нибудь в интернет: подойдет любой фтп или что-нибудь наподобие <a href="http://getcloudapp.com">CloudApp</a>, я использую последнее, потому что есть нативный клиент под Mac и он удобен в работе.</p>

<p>Дальше получаем URL для доступа к postgres базе данных heroku, для этого в папке с приложением выполнеяем (или из любой папке, но дописав к команде <code>--app app_name</code>) <code>heroku config | grep DATABASE_URL</code> и увидим длинный адрес, это и есть ссылка для доступа к БД. Если вы, как я используете cloudApp, то знайте, что, когда вы копируете ссылку на файл, это, не прямая ссылка и поэтому загрузить на heroku дамп у вас не получится, для того, чтобы увидеть реально прямую ссылку необходимо набрать следующее <code>curl -I http://cl.ly/2h1k1X3Z2j4f/project_development.dump | grep Location</code> и вы увидите прямую ссылку после слова <strong>&ldquo;Location: &rdquo;</strong>. Длинный и запутанный адрес это ссылка, которую вам дал cloudApp для доступа к файлу.</p>

<p><img class="image" src="/images/posts/2013-01-slite3-to-posgres-migration/Screen-Shot-2013-01-25-at-12.05.28-PM1-300x146.png"></p>

<p>После этих манипуляций давайте запустим импорт базы данных из папки с проектом <code>heroku pgbackups:restore DATABASE 'http://f.cl.ly/items/4G2u393d432U3V0u2X1d/project_development.dump'</code> если все прошло нормально, то мы увидим</p>

<p><code>
Retrieving... done
Restoring... done
</code></p>

<p>если же что-то пошло не так и вы увидели сообщение об ошибке, напишите <code>heroku logs --ps pgbackups</code> и вы увидите что именно пошло не так.</p>

<p>Надеюсь, данная заметка вам поможет перенести локальные данные на heroku или просто сделать из sqlite3 базы данных postgres или mysql.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Оповещение после выполнения "тяжелой" фоновой задачи с помощью faye и PrivatePub]]></title>
    <link href="http://zudochkin.ru/2013/01/resque-with-private-pub-and-rails"/>
    <updated>2013-01-21T22:45:24+04:00</updated>
    <id>http://zudochkin.ru/2013/01/resque-with-private-pub-and-rails</id>
    <content type="html"><![CDATA[<p>Допустим нам необоходимо после выполнения большой задачи в фоновом режиме сообщить об этом пользователю и совершить что-нибудь, например, показать ему какой-нибудь popup. <!-- more -->
Для этого по-старинке, можно с интервалом, скажем в 1 секунду опрашивать сервер и смотреть не завершилась ли наша задача, но в пору HTML5  делать это, по крайней мере, не престижно. Будем использовать для этих целей инструмент по обмену сообщениями между сервером и клиентом <strong>Faye</strong>.</p>

<h3>Инструменты</h3>

<p>Нам понадобится Rails приложение, к которому мы и будем привязывать всю эту функциональность. Также будем использовать <strong>Resque</strong> для выполнений фоновых задач &ndash; инструмент, зарекомендовавший себя, как надежный и стабильный помощник, спасающий всегда, когда нужно выполнить тяжелые задачи в фоне. Вместе с <strong>faye</strong> воспользуемся оберткой для него от Ryan Bates <strong>Private Pub</strong>, который мне очень облегчил жизнь, надеюсь, и облегчит вам.</p>

<h3>Реализация</h3>

<p>Для начала установим redis и обновим наш Gemfile, дополнив его необходимыми гемами resque, faye, private_pub, thin.</p>

<p>Я буду рассказать все на примере Mac OS, установка подобного инструментарий, скажем, на Ubuntu, не должна вызвать вопросов, потому что инструменты очень распространенные.</p>

<p>Устанавливал redis я с помощью всем известного пакетного менеджера Homebrew, напечатав в терминале всего одну команду <code>brew install redis</code></p>

<p>Допустим у нас имеется какой-нибудь тяжелый объект с несколькими картинками, которые лежат в Amazon S3 и, чтобы создать копию этого объекта нам понадобится скачать все эти картинки, чтобы вновь их туда загрузить,  привязав в новому объекту. Не спрашивайте почему так сложно, так работает CarrierWave или я просто не нашел лучшего решения.</p>

<p>Если у нас раньше был метод в контролле, к примеру, clone, которй вызывал метод из модели, делающий всю грязную работу, то сейчас нам нужно лишь добавить новую задачу для resque, выглядеть это будет примерно так</p>

<p><code>ruby
def clone
  Resque.enqueue(CloneProfileWorker, params[:id])
end
</code></p>

<p>Теперь тяжелая задача будет добавляться в очередь всякий раз, когда мы пройдем по ссылке <strong>/profiles/#{ id }/clone</strong>.</p>

<p>Давайте поставим и настроим PrivatePub, который будет со стороны клиента подписываться на определенные события, и со стороны сервера, после наступления определенного события (в нашем примере это, когда resque job отработает) делать нужные нам вещи.</p>

<p>Для этого в консоли нужно запустить <code>rails g private_pub:install</code></p>

<p>и добавить в файл app/assets/javascripts/application.js[.cofeee] строчку
<code>#= require private_pub</code>, если вы используете cofeeScript или же <code>//= require private_pub</code>, если js</p>

<p>и дальше во вьюхе <strong>/profile/clone.html.haml</strong> (я использую haml в данном проекте)</p>

<p>``` ruby
= subscribe_to &ldquo;/profile_cloning_#{ params[:id] }&rdquo;</p>

<p>:javascript
  PrivatePub.subscribe(&lsquo;/profile_cloning_#{ params[:id] }&rsquo;, function(data, channel) {</p>

<pre><code>location.href = data.url;
</code></pre>

<p>  });</p>

<p>```</p>

<p>Первая строчка это метод из гема, который инициализует объект необходимыми параметрами из файла /config/private_pub.yml, а после мы &ldquo;подписываемся на событие &lsquo;/profile_cloning_#{ params[:id] }&rsquo;, где в params[:id] содержится текущий id профиля. При наступлении данного события, мы перенаправляем пользователя на страницу &lsquo;/profile/#{ new_id }/edit&rdquo;, полный урл мы получим после того, как resque job отработает.</p>

<p><strong>app/workers/clone_profile_worker.rb</strong></p>

<p>``` ruby
require &lsquo;resque&rsquo;</p>

<p>class CloneProfileWorker
  @queue = :default</p>

<p>  def self.perform(profile_id)</p>

<pre><code>c = Profile.find profile_id
new_profile = c.clone_self

if new_profile.is_a? Profile
  PrivatePub.publish_to "/profile_cloning_#{ profile_id }", :url =&gt; "/profiles/#{ new_profile.id }/edit"
end
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>В данном воркере нет ничего магического: сначала мы клонируем наш профиль и если все прошло успешно, то оповещаем нашего клиента и передаем туда url, на который он перенаправится.</p>

<p>Проверяем работоспособность</p>

<p>Запускаем в разных окнах терминала:</p>

<ul>
<li><code>rails s</code></li>
<li><code>redis-server /usr/local/etc/redis.conf</code> (у меня MacOs, на других ОС должно быть нечто подобное)</li>
<li><code>VERBOSE=1 rake resque:work QUEUE=*</code> (запускаем все очереди, устанвливаем verbose=1 для того, чтобы видеть что происходит внутри resque)</li>
<li><code>rackup private_pub.ru -s thin -E production</code> (сервер для PrivatePub и Faye)</li>
</ul>


<p>Проходим по ссылке наподобие <strong>/profiles/73/clone</strong> и смотрим в терминале как отрабатывает наш resque job и мы перенаправляемся на редактирование уже склонированного профиля, если все отработало без ошибок. Если же возникли ошибки, то они отобразятся в терминале, если произойдет что-то невообразимое и непредвиденное, пишите в комментариях, я попробую помочь вам.</p>
]]></content>
  </entry>
  
</feed>
